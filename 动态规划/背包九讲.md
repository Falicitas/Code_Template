# 背包九讲

## 01背包

转移方程：$f[i][j] = max(f[i-1][j],f[i-1][j-w_i]+b_i)$

一维反向体积循环：$f[j] = max(f[j],f[j-w_i]+v_i)$​​

背包空间大适用。

## 完全背包

一维正向体积循环：$f[j] = max(f[j],f[j-w_i]+v_i)$

## 多重背包

多重背包的递推式：$f[i][j] = f[i-1][j'] + (j-j') / w[i]*v[i],(j-j')/w[i]<=k[i]$​​​，其中 j 与 j' 模 w[i] 同余。将决策点 $j'$ 加入单调队列中。设当前下标为 j，若 $f[i-1][j']+(j-j')/w[i] * v[i] < f[i-1][j]$​ 则弹队尾（假设维护最大值）。

可以使用滚动数组省空间。

## 可行性问题

01 背包和完全背包等价为多重背包的特例，故只讨论多重背包的可行性问题。给 n 种物品，每个物品有 k 个，能否恰好填满空间为 V 的背包？（这里不考虑物品的价值）

复杂度是 $O(nV)$ ​的。

定义状态 $dp(i,j)$ ​为选第 i 个物品，已用 j 空间时还（剩余）可选第 i 号物品的最多的数量。

``` cpp
dp[][] = -1;
dp[0][0] = 0;
for (int i = 1; i <= n; i++) {
    for (j = 0; j <= V; j++) {
        if (f[i - 1][j] >= 0) {
            f[i][j] = k[i];
        }
    }
    for (j = 0 to V - c[i]) {
        if (f[i][j] > 0) {
            f[i][j + c[i]] = max(f[i][j + c[i]], f[i][j] - 1);
        }
    }
}
//答案dp[n][V]>=0
```

## 混合背包

如下

$$
\begin{aligned}{}
&for \quad i \leftarrow 1 to N\\
&\qquad if\ 第 i 件物品属于 01 背包 \\
&\qquad\qquad    ZeroOnePack \left(F, C_{i}, W_{i}\right)\\
&\qquad else\ if\ 第 i 件物品属手完全背包 \\
&\qquad\qquad    CompletePack \left(F, C_{i}, W_{i}\right)\\
&\qquad else\ if\ 第 i 件物品属手多重背包 \\
&\qquad\qquad    MultiplePack \left(F, C_{i}, W_{i}, N_{i}\right)\\
&\end{aligned}
$$
照上述三类 dp 进行 dp 即可。不必省空间。

## 二维费用

一个物品产生两方面的费用，记为 $f(i,j,k)$​​。$f(i,j,k) = max(f(i-1,j,k),f(i-1,j-c1[i],k-c2[i])+w[i])$​​。可以将第一维优化。

## 分组的背包问题

基于 01 背包的原理，每组物品只选一个 or 不选，写出转移方程：

$f[k][j] = max(f[k-1][j-c[i]]+w[i])$​，$i\in$ 第 k 组的元素。复杂度 $O(nV)$

一维的代码：

```cpp
vector<vector<int>> cluster;
for (int i = 0; i < cluster.size(); i++) {
    for (int j = V; j >= 0; j--) {
        for (int t = 0; t < cluster[i].size(); t++) {
            int ww = w[cluster[i][t]];
            int bb = b[cluster[i][t]];
            if (j >= ww) {
                dp[j] = max(dp[j], dp[j - ww] + bb);
            }
        }
    }
}
```

## 树形背包

树形背包用来求包含根节点在内的一个极大权联通块。即一个节点选择了，那么其祖先节点均需被选择，也等同于一个节点不选，其子树任意一个子节点都不选的背包问题。

### dfs序求树上背包

按照 dfs 序考虑：

我们设 dp(i,j) 表示考虑到第 i 个，剩余容量为 j 的状态：

有两种转移：

1、不选 i，那么 i 的子树都不能选，转移到 dp(i+siz[i],j)。

2、选 i，那么按照dfs序考虑下一个，转移到 dp(i+1,j+w)+v。

正确性显然。

### 一类 $O(nV)$ 的树上背包

有一类树上背包，第二维表示子树内选的点数且限制第二维不超过 m，其总复杂度可证明为 $O ( n m )$​。

```cpp
void dfs(int u, int fa) {
    siz[u] = 1;
    // initialize dp[u]
    for (auto v : e[u]) {
        if (v == fa)
            continue;
        dfs(v, u);
        for (int j = 0; j <= min(m, siz[u]); ++j) {
            for (int k = 0; k <= min(m - j, siz[v]); ++k) {
                // dp[u][j] * dp[v][k] -> dp[u][j+k]
            }
        }
        siz[u] += siz[v];
    }
}
```

复杂度证明（siz[u] 表示已经合并的子树的总大小）：

$siz[u] \geq m,  siz[v] \geq m$：一次合并的复杂度为 $O\left(m^{2}\right)$ 。考虑所有的极小的 $size \geq m$ 的子树（即它里面的所有子树的 $s i z e$ 都小于 $m$。简称为极小的子树），显然它们两两不相交，所以至多有 $\frac{n}{m}$ 个。此外， 这种情况会出现，当且仅当：$u$ 已经合并过的儿子里有极小的子树，并且 $v$ 里面有极小的子树。故而合并的次数为极小的子树个数 $-1$ 。这一部分的复杂度是 $O\left(m^{2} \cdot \frac{n}{m}\right)=O(n m)$​​​。

$siz[u] \geq m,  siz[v]<m$​​​​​：这种情况的复杂度是 $O(m \cdot si  z [v])$​​​​​ ，我们考虑求 $\sum s i z e[v]$​​​​​ 的上界。考虑一颗树结构，满足 $s i z [x]<m \wedge siz\left[f a_{x}\right] \geq m$​ 的点 x 代表的子树彼此不交叉，所以 $\sum siz[v]=O(n)$​，所以这种情况的总复杂度 $O(n m)$​​。

$siz[u]<m,  siz[v] \geq m$ 单次复杂度 $O(siz[u]*m)$。我们考虑求 $\sum s iz[u]$ 的上界。对于 $s z[u]$ 中的每个点考虑，它的祖先中出现这种情况的 $u$ 也至多有一个、并且每个 $u$ 只会出现至 多一次这种情况，所以 $\sum s z[u]=O(n)$ 。

$s iz[u]<m,   siz [v]<m$​，这个时候就是普通的树形背包，对于一整棵大小为 $x$​ 的树我们知道这样的复杂度是 $O\left(x^{2}\right)$​ 。考虑所有的、极大的 $s i z e<m$​ 的子树 (即满足 $\operatorname{size}\left[f a_{x}\right] \geq m$​ )，每一个这样的子树的复杂度是 $O\left(m^{2}\right)$​ ，而这样的子树两两不相交，所以至多有 $\frac{n}{m}$​ 个，所以总复杂度为 $O\left(m^{2} \cdot \frac{n}{m}\right)$​。(i+siz(u),j),dp(i,j))$。表示不选当前节点，那么子树也必然不选。

## 泛化物品

这里是对物品的一般化：对于一个泛化物品，给定一个费用v，就对应一个价值w。写成映射就是:$h[v]=w_v,v\in [0,V]$。只是将上面的思路抽象出来而已，掌握上面原理更重要。

## 输出方案

基础的操作。对于估值函数 $f(i,j,k)$，多创建一个 $pre(i,j,k)$，记录更新 $(i,j,k)$ 状态的 $(i',j',k')$。字典序最小的话便考虑倒着求（指动态规划从 $n\sim1$，由 1 往 n 回溯）。有些小细节，比如倒着求时 “不选当前的最优值”==“选当前的最优值”，那需由选当前的来更新（因为当前的下标更小）。

## 最优方案的总数

用两个数组来记录。$f[i][j]$​ 为最优方案，$g[i][j]$ ​为最优方案的路径数。很明显，$f[i][j]$ ​由谁更新，$g[i][j]$ ​就加谁。

## 第k优解

原理跟图论有关。假设一个点可以从两个点出发到达，那么这个点的路径方案就是两个点方案的总和。第 k 优解将每个点的状态存储的解视为一个有序数组，若一个点可以从两个决策中到达，那么这个点的方案就是两个决策的有序数组的合并。由归并排序的思路可知，合并的复杂度是 $O(k)$ ​的。故对于估价函数 f，只需加一维长度为 k，合并时取可做决策的前 k 大/前 k 小即可。

## 习题

### 2021牛客暑期多校训练营4 D

对于一棵树，边集为 S。另外使 $T\in E$，$E = \{<i,j>|i<j\}$​。现在从 S 去掉 k 条边，E 中选 k 条构成 T，$T\cup S$ 构成一棵树。求 $T$ 的方案数。$n\le 1e5,k\le \min(n-1,100)$。

问题分成两步：将树分成 k+1 个联通块，每个联通块记大小为 $s_i$。统计联通块构成树的方案。

后者比较好求：根据 prufer 序列，联通块构成树的方案为 $n^{k-1}\prod_{i=1}^{k+1}s_i $。

那么问题转成树上分成若干联通块，$\sum\prod s_i$ 的贡献。

这个问题不好求，看似又要维护联通块个数，又要维护当前联通块的大小；

将问题转化成，将树上分成若干联通块，每个联通块里选一个点的方案数。利用组合数学简化了状态表达。

$f_{u,j,0/1}$​​ 表示子树 u 划分了 j 个联通块，u 当前的联通块是否选了点的方案数。那么答案就是 $f_{rt,k+1,1}$。

$j \le \min(siz(u),k+1)$，可以预见是一类 $O(nk)$ 的树上背包了。

具体的，枚举每个 son，$cur_{u,j,0/1}$ 为当前已算得的 $f_{i,j,0/1}$​ 的值，考虑当前 son 是否合并到 u 表示的联通块中：
$$
\begin{aligned}
&cur_{u,j,0} * f_{v,t,1} \rightarrow f_{u,j+t,0}
\\
&cur_{u,j,1} * f_{v,t,1} \rightarrow f_{u,j+t,1}
\\
&cur_{u,j,0} * f_{v,t,0}\rightarrow f_{u,j+t-1,0}
\\
&cur_{u,j,1} * f_{v,t,0} + cur_{u,j,0}*f_{v,t,1} \rightarrow f_{u,j+t-1,1}
\end{aligned}
$$
复杂度 $O(nk)$。
