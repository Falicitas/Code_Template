# 字符串合集

## 扩展KMP

```cpp
#include <bits/stdc++.h>
using namespace std;

void GetNext(char T[], int m, int next[]) {
    int a = 0, p = 0;
    next[0] = m;

    for (int i = 1; i < m; i++) {
        if (i >= p || i + next[i - a] >= p) {
            if (i >= p)
                p = i;

            while (p < m && T[p] == T[p - i])
                p++;

            next[i] = p - i;
            a = i;
        } else
            next[i] = next[i - a];
    }
}

/* 求解 extend[] */
void GetExtend(char S[], int n, char T[], int m, int extend[], int next[]) {
    int a = 0, p = 0;
    GetNext(T, m, next);

    for (int i = 0; i < n; i++) {
        if (i >= p || i + next[i - a] >= p)  // i >= p 的作用：举个典型例子，S 和 T 无一字符相同
        {
            if (i >= p)
                p = i;

            while (p < n && p - i < m && S[p] == T[p - i])
                p++;

            extend[i] = p - i;
            a = i;
        } else
            extend[i] = next[i - a];
    }
}

int main() {
    int next[100];
    int extend[100];
    char S[100], T[100];
    int n, m;

    while (scanf("%s%s", S, T) == 2) {
        n = strlen(S);
        m = strlen(T);
        GetExtend(S, n, T, m, extend, next);

        // 打印 next
        cout << "next:   ";
        for (int i = 0; i < m; i++)
            cout << next[i] << " ";

        // 打印 extend
        cout << "\nextend: ";
        for (int i = 0; i < n; i++)
            cout << extend[i] << " ";

        cout << endl
             << endl;
    }
    return 0;
}

```

## AC自动机

```cpp
//code sourced from kinesis
#include<bits/stdc++.h>
using namespace std;

#define _REP(i,a,b) for(int i = (a) ; i >= (int)(b) ; --i )
#define REP(i,a,b) for(int i = (a) ; i <= (int)(b) ; ++i )
#define UREP(i,u) for(int i = p[(u)] ; i + 1 ; i = edge[i].next)
//iterator: for(int u:x),x is container
#define x(p) (p).first
#define y(p) (p).second
#define pii pair<int,int>
#define mp(x,y) make_pair((x), (y))
#define sign(x) (fabs(x) < eps ? 0 : ((x) > 0 ? 1 : -1))
#define ll long long
#define L7 __int128//1<<7 bit
#define ull unsigned long long
const int inf = 0x3f3f3f3f;
const ll inff = 0x3f3f3f3f3f3f3f3f;
const int mod = 998244353;
const double eps = 1e-9;
#define ri1(x) scanf("%d", &(x))
#define ri2(x,y) scanf("%d%d", &(x), &(y))
#define ri3(x,y,z) scanf("%d%d%d", &(x), &(y), &(z))
#define ri4(a,b,c,d) scanf("%d%d%d%d", &(a), &(b), &(c), &(d))
//sort(f,f+n,[](int x,int y){return g[x] < g[y];});绑定sort
//#define Debug
#ifdef Debug
#endif // Debug

const int N = 2e4 + 5;
int tr[N][26],tot,exi[N],n,fail[N];
char s[155][100],t[1000005];int st[N];
struct E
{
    int v,next;
}edge[N<<1];
int p[N],eid;
void init_E(){memset(p,-1,sizeof p),eid = 0;}
void link1(int u,int v){edge[eid].v = v,edge[eid].next = p[u],p[u] = eid++;}

void ins(int id)
{
    int u = 0;
    for(int i=0;s[id][i];i++){
        int c = s[id][i] - 'a';
        if(!tr[u][c]) tr[u][c] = ++tot;
        u = tr[u][c];
    }
    exi[u] = 1,st[u] = id;
}

void bld()
{
    queue<int> q;
    REP(i,0,25){
        if(tr[0][i]) link1(0,tr[0][i]),q.push(tr[0][i]);//printf("##%d\n",tr[0][i]);
    }
    while(!q.empty()){
        int u = q.front();q.pop();
        REP(i,0,25){
            if(tr[u][i]) fail[tr[u][i]] = tr[fail[u]][i],q.push(tr[u][i]),link1(fail[tr[u][i]],tr[u][i]);//,printf("?%d %d\n",fail[tr[u][i]],tr[u][i]);
            else tr[u][i] = tr[fail[u]][i];
        }
    }
}

int d[20000];

void dfs(int u)
{
    UREP(i,u){
        int v = edge[i].v;
        dfs(v);
        d[u] += d[v];

    }//printf("!@@!$%d %d\n",u,d[u]);
}

void run()
{
    memset(tr,0,sizeof tr),tot = 0;
    memset(exi,0,sizeof exi);
    memset(d,0,sizeof d);memset(p,-1,sizeof p),eid = 0;
    memset(fail,0,sizeof fail);
    REP(i,1,n) scanf("%s",s[i]),ins(i);
    bld();
    //printf("?%d\n",tot);
    //REP(i,1,tot) printf("%d\n",fail[i]);
    scanf("%s",t);
    int u = 0;
    for(int i=0;t[i];i++){
        int c = t[i] - 'a';
        u = tr[u][c];
        d[u]++;
        //printf("%d\n",u);
    }
    dfs(0);
    int maxx = 0,cnt = 0;
    //printf("??????%d\n",tot);
    REP(i,1,tot) if(exi[i]){
        if(maxx<d[i]) maxx = d[i],cnt = 1;
        else if(maxx==d[i]) cnt++;
    }
    printf("%d\n",maxx);
    REP(i,1,tot) if(exi[i]&&d[i]==maxx){
        printf("%s\n",s[st[i]]);
    }
}
/*
2
aba
bab
ababababac
*/

int main()
{
    #ifndef ONLINE_JUDGE
    //freopen("in.txt","r",stdin);//cf,atcoder,nowcoder needn't delete this
    #endif // ONLINE_JUDGE
    while(ri1(n)==1&&n) run();
    return 0;
}

```

## SA

```cpp
#include <bits/stdc++.h>
#define rint register int
#define inv inline void
#define ini inline int
#define maxn 1000050
using namespace std;

struct SA {
    string s;
    vector<int> y, x, c, sa, rk, height;
    int n, m = 122;

    SA(string s_)
        : s(s_) {  //从下标1开始
        n = s.length() - 1;
        y = vector<int>(n + 1), x = y, c = y, sa = y, rk = y, height = y;
        c = vector<int>(max(n, m) + 5);
        for (int i = 1; i <= n; ++i) {
            ++c[x[i] = s[i]];
        }
        // c数组是桶
        // x[i]是第i个元素的第一关键字
        for (int i = 2; i <= m; ++i) {
            c[i] += c[i - 1];
        }
        //做c的前缀和，我们就可以得出每个关键字最多是在第几名
        for (int i = n; i >= 1; --i) {
            sa[c[x[i]]--] = i;
        }
        for (int k = 1; k <= n; k <<= 1) {
            int num = 0;
            for (int i = n - k + 1; i <= n; ++i) {
                y[++num] = i;
            }
            // y[i]表示第二关键字排名为i的数，第一关键字的位置
            //第n-k+1到第n位是没有第二关键字的 所以排名在最前面
            for (int i = 1; i <= n; ++i) {
                if (sa[i] > k) {
                    y[++num] = sa[i] - k;
                }
            }
            //排名为i的数 在数组中是否在第k位以后
            //如果满足(sa[i]>k)
            //那么它可以作为别人的第二关键字，就把它的第一关键字的位置添加进y就行了
            //所以i枚举的是第二关键字的排名，第二关键字靠前的先入队
            for (int i = 1; i <= m; ++i) {
                c[i] = 0;
            }
            //初始化c桶
            for (int i = 1; i <= n; ++i) {
                ++c[x[i]];
            }
            //因为上一次循环已经算出了这次的第一关键字 所以直接加就行了
            for (int i = 2; i <= m; ++i) {
                c[i] += c[i - 1];
            }  //第一关键字排名为1~i的数有多少个
            for (int i = n; i >= 1; --i) {
                sa[c[x[y[i]]]--] = y[i], y[i] = 0;
            }
            //因为y的顺序是按照第二关键字的顺序来排的
            //第二关键字靠后的，在同一个第一关键字桶中排名越靠后
            //基数排序
            swap(x, y);
            //这里不用想太多，因为要生成新的x时要用到旧的，就把旧的复制下来，没别的意思
            x[sa[1]] = 1;
            num = 1;
            for (int i = 2; i <= n; ++i) {
                x[sa[i]] = (y[sa[i]] == y[sa[i - 1]] &&
                            y[sa[i] + k] == y[sa[i - 1] + k])
                               ? num
                               : ++num;
            }
            //因为sa[i]已经排好序了，所以可以按排名枚举，生成下一次的第一关键字
            if (num == n) {
                break;
            }
            m = num;
            //这里就不用那个122了，因为都有新的编号了
        }
        for (int i = 1; i <= n; ++i) {
            cout << sa[i] << " ";
        }
        cout << "\n";
    }
    void get_height() {
        int k = 0;
        for (int i = 1; i <= n; ++i) {
            rk[sa[i]] = i;
        }
        for (int i = 1; i <= n; ++i) {
            if (rk[i] == 1) {
                continue;
            }  //第一名height为0
            if (k) {
                --k;
            }  // h[i]>=h[i-1]+1;
            int j = sa[rk[i] - 1];
            while (j + k <= n && i + k <= n && s[i + k] == s[j + k]) {
                ++k;
            }
            height[rk[i]] = k;  // h[i]=height[rk[i]];
        }
        for (int i = 1; i <= n; ++i) {
            cout << height[i] << " ";
        }
        cout << "\n";
    }
};
int main() {
    string s;
    cin >> s;
    s = "0" + s;
    SA sa(s);
    return 0;
}
```

