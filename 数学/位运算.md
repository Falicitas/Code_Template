# 位运算

## 判断数是否为2的正整数幂

```c++
bool isPowerOfTwo(int n) { return n > 0 && (n & (n - 1)) == 0; } 
```

证明：当不是2的正整数幂，低位必存在1。减1时最高位不会降位，取交必不为0。

是2的正整数幂，想象一下就是了。

## 取绝对值

```cpp
int Abs(int n) {  return (n ^ (n >> 31)) - (n >> 31);}  /* n>>31 取得 n 的符号，若 n 为正数，n>>31 等于 0，若 n 为负数，n>>31 等于 -1     若 n 为正数 n^0=n, 数不变，若 n 为负数有 n^(-1)     需要计算 n 和 -1 的补码，然后进行异或运算，     结果 n 变号并且为 n 的绝对值减 1，再减去 -1 就是绝对值 */ 
```



其实是不会用它的、、但据传言 一些机器，上个取绝对值比`n > 0 ? n : -n`  快、、同时也$n<<1$比*2快、、证明位运算是$O(1)$的。

## 集合运算

$A - B = A \& (\sim B)$

$A \Delta B = A $^$ B$ 

## 枚举子集的子集复杂度

$O(3^n)$。

证明：划分n个元素的子集为含$0,1,2,...,n$个元素的子集，对应的个数$C_n^0,C_n^1,C_n^2,...,C_n^n$。每个又对应$2^0,2^1,2^2,...,2^n$个子集。故$(1+2)^n = C_n^0 * 2^0 + C_n^1 * 2^1 + C_n^2 * 2^2 + ... + C_n^n * 2^n = 3^n$

## 用于位运算的内建函数

```cpp
int __builtin_ffs(int x)//等价于x & (-x)，返回x最后一位1的值
int __builtin_clz(unsigned int x)//返回前导0的个数（从高位到低位，比如1返回31），x=0未定义
int __builtin_ctz(unsigned int x)//返回末尾0的个数（从低位到高位，比如1返回0），x=0未定义
int __builtin_popcount(unsigned int x)//x的1的个数，可以预处理
```

枯了，由于是内建函数，运算速度非常快（有些甚至只需要一条指令），，所以$ \_\_builtin\_popcount(n)$放心用。。

如果n是（无符号）长整型，则用$\_\_builtin\_popcountll(n)$来计算个数。

### 一些应用

> 1. 可以用$32-\_\_builtin\_clz(n)$表示n的2进制位数、、取底数为2的对数则是位数-1即$32-\_\_builtin\_clz(n)$

### 手写bitset



## 一些习题

### P5657 格雷码

找规律、、注意$(1<<n)$是$int$型的，$(1ull<<n)$才是长整型的。

### P5514 [MtOI2019]永夜的报应

证明$A+B>=A$^$B$ ,其中$A,B$均可表示单个数的异或和 或者 一组数的异或和。

对于两个数的每一位仅4种情况，0 ^ 0 <= 0 + 0, 1 ^ 0 = 0 ^ 1 <= 0 + 1,1 ^ 1 <= 1 + 1。故对两个数，比起分成两组，不如直接异或起来。

答案即为所有数的异或和。

### P5538 【XR-3】Namid[A]me

用点分治和哈希加速~~水了一个~~AC（逃

用点分治降低树上方案统计复杂度，将决策点加入到hash中，然后分治计算方案、、当时码的时候，极度害怕过多决策点，复杂度趋于$O(n^2)$，不过由于与操作，单个子树最多产生$O(|S|*30)$的决策点，其中$|S|$是现有决策集的秩、、虽然还是数量巨大。。

计算$x^x(\%p)$时可用原根加速取模（参考了标答的做法，原本用快速幂TLE了。。）根据原根性质，x可以被原根表示$x\equiv g^k(\%p),x^x \equiv (g^k)^{g^k} \equiv g^{kg^k}(\%p)$,取以$g$为底的离散对数，

$Indx \equiv k$,故$x^x \equiv g^{x*Indx}(\%\varphi(p))$

故$x^x\equiv x*Indx$,预处理对数和g的幂，介样子就可以就可以$O(1)$求了qwq

### P5539 【XR-3】Unknown Mother-Goose

手写bitset大暴力。。

当元素$x=a_i>=64$，直接暴力更新bitset的$0/1$；当小于64时，由于是模加系统，当处在$ka,k = 1<<6$时，构成了若干个完整块且进入循环节，此时按循环节更新bitset的每个块、、

需要求得是连续三个1的个数，等于每个块内的和相邻块间的方案。仅讨论块内的，一个块$bs[i]$中连续三个1的个数等于$\_\_builtin\_popcountll(bs[i] \& (bs[i]>>1) \& (bs[i]>>2))$

另外bitset里位移的$1$为$1ull$，不然是32位整型、、还有位移运算要括起来。。。优先级太低了。。。类似$(bs[(N>>6)+10])$

### P5523 [yLOI2019] 珍珠

观察运算性质，和递推临近元素关系。

对于与非而言，依次与非遇到0时，不管前面运算结果是1 or 0，经过此位必为1。则只需要找到p位置对应最近0的位置，然后$O(1)$求$1\ nand\ 1\ nand\ 1...$

由于都是从两头插值，故有递推的特殊性质。当推0时，与0相邻的连续1的相近0改变；推1时，则由原来一侧的相近0递推得出、、

最后实现细节就是了，，

### 可达性统计

给一个图，输出每个点能到其他哪些点。

用bitset优化状态储存，每个点经过的点由直接可达点的状态取并而来、、 

