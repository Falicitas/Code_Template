# 博弈论和SG函数

P：必败点；N：必胜点。

必胜点和必败点的性质（**非平局博弈的原理**）：

◦ 所有 **终结点** 是必败点 P。
◦ 从任何必胜点 N 操作，**至少有一种方式**可以进入必败点 P。
◦  **无论如何操作，必败**点 P 都只能进入必胜点 N。

## Nim及SG

有向图移动游戏可以看作所有 *Impartial Combinatorial Games* 的抽象模型。NIM 游戏就是 *Impartial Combinatorial Games* 其中的一种。

> 所有 ICG 游戏都可以看成：给定一个 DAG 及一个点上的一个棋子，两名选手交替将棋子沿边移动，无法移动判负。故 Nim游戏可抽象成有向图上的游戏。

Nim 和：Nim 游戏的博弈结果为：$𝑏_1 ⨁𝑏_2 ⨁\dots⨁𝑏_n = 0$必败；反之必胜。其由 *Bouton’s Theorem* 推得。

> 我们设 $𝑏_1 ⨁𝑏_2 ⨁\dots⨁𝑏_n = l$​​，那么设 $l$​ ​二进制表示下最高位的 1 为第 $p$ ​​位。
>
> 那么，$𝑏_1 ⨁𝑏_2 ⨁\dots⨁𝑏_n$​​ 中必定存在至少一个 $𝑏_𝑗$​​ 使得 $𝑏_𝑗$​​ 二进制表示下第 $𝑝$ ​​位为 1。
>
> 从而，将第 $𝑗$​​ ​堆石头取 $𝑏_𝑗 − 𝑏_𝑗 ⨁𝑙$​ ​​个石头（即将 $b_j\rightarrow b_j \bigoplus l$​​​）即可保证一定到达P点。
>
> 而当 $l$​​ 等于零时，由于 $b_j = b_j \bigoplus l$​​，故其操作不合法，只能转移到 N 点。

SG 函数是由图的性质得到。定义：$SG(x) = \{mex(\{SG(y)\})|<x,y>\in E\}$​。根据**非平局博弈**的原理，得到当$SG(x) = 0,$​属$P$​点；$SG(x)\neq 0,$​属$N$​点。

SG 定理：若干个独立游戏的 **复合** 的博弈结果为：$SG(X) = \bigoplus\limits SG(X_i)$​。

若将 $SG(X) = a$​​ 视作 Nim 的异或和来理解，即每次选一个游戏将该游戏的 $SG(X_i)$​​ 转移到 $SG(X_i)\bigoplus a$​​​ 中，就可以从 *Bouton’s Theorem* 中~~感性~~理解。

## Fibonacci 博弈及 k 倍动态减法

有 n 个球。第一个人首先能取 $[1,n-1]$​ ​​个球，之后游戏开始：每一轮玩家只能取上个玩家取过的球不超过 $k = 2$ ​​​倍个数的球，问博弈结果。

这类问题称作 Fibonacci 博弈，这里先引入**齐肯多夫定理**。

> 齐肯多夫定理
>
> 定理：任何正整数都可分解为不连续的 Fib 数。
>
> 数归：$1 = F(1),2 = F(2),3 = F(3),4 = F(3) + F(1)$（基础）
>
> 对于 $m$ ​以下的数成立（假设）
>
> 对于 $m$​​，如果是 $n = F(n_1)$ ​​不需讨论；
>
> 设 $F(n_1)<m<F(n_1+1)$​，$m' = m - F(n_1)$​。
>
> 根据不等式有，$m' = m - F(n_1) < F(n_1+1) - F(n_1) = F(n_1-1)$，即$m' < F(n_1-1)$
>
> 由于 $m'$​​ ​可分解为 $m' = F(n_{t_1}) + F(n_{t_2})+\dots F(n_{t_q}),n_{t_1}<n_{t_2}<\dots<n_{t_q}$​​ ​且不连续，由上面不等式得 $n_{t_q} < n_1 - 1$​​​，即 $n_{t_q},n_1$​​​ 不连续。所以 $m = F(n_1)+m'$​​​ 也可分成不连续的 Fib 数。

根据齐肯多夫定理，可以将 $n$​ ​分为若干个不连续的数。而对于不连续的 Fib 数 $ F(t_1)<F(t_2)$​​有$\frac{F(t_2)}{F(t_1)}>2$​​（展开即得证）。当 $n$ ​​不为 Fib 数时，其分解成一个以上的不连续的数，此时先手只要取最小的 Fib 数（比如 12 分解成 8+3+1，此时取 1），由于后手拿不到其他 Fib 数（这里就是拿不到 8,3，由于相隔大于取数的**两倍**，使其拿不到后面的数），不论取什么数，之后的原先手都可以拿按 Fib 分解的最小的那个数直至胜利。

### K倍动态减法

K 倍动态减法是 Fibonacci 的扩展。

扩展体现在数列是根据 $k$ 的值自行构造的。具体构造方法如下：

首先考虑 $k$​ 的平凡情况：

> 1. 当 $k = 1$​ 时，必败态为 $n = 2 ^ i$​​（把数按二进制分解后，拿掉二进制的最后一个 1，那么对方必不能拿走倒数第二位的 1，因为他不能拿的比先手多），按照这个策略就会赢。而当分解的二进制中只有一个 1 时，因为第一次先手不能全部取完，所以后手一定有办法取到最后一个1，所以必败。
>
>    举例，当 $n = 6 = (110)_2$​ 时:
>
>    第一轮：先手第一次取最右边的 1，即 2 个，此时还剩 $4(100)_2$​ 个，后手能取 1 或 2 个；
>
>    第二轮：假如上轮后手取的两个，先手再取两个直接赢了。
>
>    假如后手取了一个，那么还剩三个，自己只能取 1 个，以后也只能取一个，所以必胜。
>
> 2. 当 $k = 2$​ 时，就是 Fibonacci 博弈。

当 $k$ 取任意非零正值时：

与 Fibonacci 博弈类似，首先要求一个数列。将 $n$​​​ **分解成数列中一些项的和**，就可以按 Fibonacci 博弈的思路解决。

具体地，用 $a$​​ 数组表示要求的数列，$b$​​ 数组中的 $b[i]$​​ 保存 $a[0...i]$​​ 组合能够构造的最大数字。

构造就是指 $n$​​ ​分解为 $a$​ ​​数列相加的逆过程。比如当 $k = 2$​​​ 时，$a[N]={1, 2, 3, 5, 8, 13, 21, 33....}$​​​ （Fibonacci 数组）；那么 $b[3]$​​​ 即 $1,2,3$​​​ 能够构造的最大数字为 4（由于是贪心取最大数分解）。

由于 $b[i]$​​​ 是 $a[0...i]$​​​ 能够构造出的最大数字，那么 $a[i +1] = b[i]+1$​​​；因为 $a$​ ​​数组所存的数字都是 **不可构造** 的（取到它本身就是必败态），显然 $a[0...i]$​​​ 构造的最大数字 $+ 1$​​​ 即为下一个不可构造的数字了（$a[i + 1]$​​​​）。

关于 $b[i]$​​​​​​​​​​​​​​​​ 的计算，既然是 $a[0...i]$​​​​​​​​​​​​​​​ ​构造的最大数字，那么 $a[i]$​​​​​​​​​​​​​​ ​​是要选用的（基于贪心取数）。要选用的下一项只能递减寻找，直到找到 $a[t]$​​​​​​​​​​​​​​​​ 满足 $a[t] * K < a[i]$​​​​​​​​​​​​​​​​，而 $b[t]$​​​​​​​​​​​​​​​​ 就是 $a[0...t]$​​​​​​​​​​​​​​​​ 所能构造的最大数字（这样就能保证 $[b[i-1]+1,b[i]]$​​​​​​​​​​​ 的数取了 $a[i]$​​​​​​​​​​ ​后，下一个数取值小于 $a[i]$​​​​​​​​​ ​​的 $\frac{1}{K}$​​​​​​​​ ​​​倍），再加上 $a[i]$​​​​​​，​​​​​即为 $a[0...i]$​​​​​​ ​​​​​能构造的最大数字，于是 $b[i] = b[t] + a[i]$​​​​​​​​​​​（观察这个式子，$b[t]$​​​​​​​​​​​ 表示了 $[1,b[t]]$​​​​​​​​​​​ 的数所取的最大为 $a[t]$​​​​​​​​​​​，而 $a[t]*K<a[i]$​​​​​​​​​​​，所以该式满足题目需求）。细节：当 $t$​ ​​​​​​​​​​不存在时，$b[i] = a[i]$​​​​​​​​​​​​​​​​​​​。

代码：

```cpp
void run()
{
    int n,k;
    ri2(n,k);
    int i = 0,j = 0;a[0] = b[0] = 1;
    while(a[i]<n){
        i++;
        a[i] = b[i-1] + 1;
        while(1LL * a[j+1] * k < a[i]) j++;
        b[i] = a[i] + (1LL * a[j] * k < a[i] ? b[j] : 0);
    }
    if(n==a[i]) printf("lose\n");
    else{
        int ans = 0;
        while(n){
            if(a[i]<=n) n -= a[i],ans = a[i];
            i--;
        }
        printf("%d\n",ans);
    }
}
```



## Anti-Nim & Anti-SG

Anti-Nim：第一个从非空取到空的必败。

> 必胜条件：
>
> 1、石子堆每堆只有一个石子，且堆数为偶数。
>
> 2、石子堆至少有一个堆石子大于 1，且整体异或不为 0。
>
> 证明：
>
> 设石子数异或和为 𝑝，那么：
> 1. 石子堆数均为 1 时：
>       ◦ A) 𝑝 = 0 即偶数堆，先手必胜。
>     ◦ B) 𝑝 = 1 即奇数堆，后手必胜。
>
> 2. 当只有一堆石子数大于 1 时：那么显然 𝑝 ≠ 0。
>       ◦ A) 总共有奇数堆石子，那么把大于 1 的那堆取到1个石子，转化为 1B，从而先手必胜；
>     ◦ B) 总共有偶数堆石子，那么把大于 1 的那堆取完，转化为 1B，从而先手必胜。
>
> 3. 当有两堆及以上石子数大于1时：
>       ◦ A) 𝑝 = 0，那么先手可以转化为以下两个子状态：
>     ◦ ① 至少两堆及以上的石子数大于 1 且 𝑝 ≠ 0，转化为3B；
>     ◦ ② 只有一堆石子数大于 1，由 2A / 2B 可知必败。
>     ◦ B) 𝑝 ≠ 0，则根据 *Bouton Theorem*，总有一种方法能转化为 3A 状态。
> 
>3B 总能把 3A 状态扔给对方，而 3A 状态只能转化回 3B 状态或直接转化为 2A / 2B 状态。而 2A / 2B 状态必胜，所以 3B 状态总占先机。从而将 2 和 3B 状态合并得到结论中的 2.结论中的 1 显然。

Anti-SG 对应 SJ 定理：

> 对于任意一个 Anti-SG 游戏，如果定义所有子游戏 SG 值为 0 时游戏结束，先手必胜条件：
>
>  1. 游戏的 SG 值为 0 且所有子游戏的 SG 值均不超过 1；
>  2. 游戏的 SG 值不为 0 且至少一个子游戏的 SG 值超过 1。
>
> 证明则把问题转成 Anti-Nim 然后~~感性理解~~。

## SG函数总结

一般的 SG 函数问题结合 SG / SJ 定理解决。有些不好求 SG 函数（公式归纳不出，或者依赖公式的复杂度过高）的题目考虑打表（人类智慧）来求解。有些题目只需求部分 SG 函数，此时记忆化搜索解决。还有递推，转化模型等方法论。

## 一些习题

### CF293A Weird Game

给两个 $2n$​ 的 01 串，两个人相互取数字。一个人取完某一位置的数字，另一个人不能取对应位置的数字。问游戏结束时两个人组合出最大的数字谁更大。

由于两个人最后得到的串长相等，数字更大的等价于拿 1 拿的更多。

首先对于对应位置均为 1 的优先拿。这里要考虑**奇偶问题**，如果是奇，先手能多拿一次，但之后的状态为另一个人先手；是偶，先手后手拿同样数，之后仍是初始先手拿。对于 $(0,1),(1,0)$​，优先拿自己为 1 的数（由于这两状态同时存在时两个人不会有分差，仅需讨论存在一种情况的拿的分数（直接减去两状态中较小的那一个））。最后 $(0,0)$​ 就没差别了。

**模拟取数的过程一定要细心**（这是个很现实的问题，一旦模拟错误整题就崩了）。

### HDU 1847 Good Luck in CET！

有一个数 $n$​，每次只能拿 $2^k,k\in N$​，问先手的情况。$n\in [0,1000]$​

很好写，$n = 0$​ 必败，然后从已知状态转移就行，$nlogn$​。或者打表找规律，发现 $n=3k$ ​均为必败，其余必胜。

### Hackerrank Bob and Ben

给个森林，每次可以删掉一个叶节点或整一棵树。叶子节点定义为度为1的点。问博弈结果。

发现 $SG(1) = 1,SG(2) = 0$​（注意叶节点定义）此后 $SG(2m) = 2,SG(2m+1) = 1$​​​，用 SG 定理即可。

### [HNOI2007]分裂游戏

模拟发现只跟瓶子中石子个数的奇偶有关，故只需考虑 01 的情况。

考虑只有一个瓶子中有一个石子的情况，最后该石子要挪到最后一个瓶子中。因此可以考虑将一个石子当做一个游戏，每次移动产生了两个子游戏，根据 SG 定理，两个子游戏异或起来；所有能到达的游戏取 mex 就能解决该题的博弈结果。

在 IGC 游戏中，初始状态 SG 值为 0 必败；SG 值不为 0 时，将状态转移到 SG 值为 0 使先手必胜。故该题也如此。将初始状态所有小石子（视作一个小游戏）异或起来得到 $SG(X)$​​​​，考虑 $SG(X)\neq 0$​​​​，则先手必胜的操作就该将 $X\rightarrow X',SG(X') = 0$​​​​。由于是 IGC 游戏，只改变一个独立小游戏，故只需找到令 $X_i\rightarrow X_i',SG(X)\oplus SG(X_i)\oplus SG(X_i') = 0$​​​​ 的 $X_i$​​​​，那么第一步操作的就是小游戏 $X_i$ ​​​​​​了。

### [bzoj1457] 棋盘游戏

$100 * 100$​ ​的棋盘上有 n 个 Queen，只能向左，向下，向斜下走。两个人分别操控一个 Queen，当**一个 Queen** 移动到 $(1,1)$​ ​​就算操作那位赢。问博弈结果。

首先以 $(1,1)$​​​​​​ ​为出发点的上，右，右斜上，棋子一旦处于这些位置先手必赢，同时博弈过程中也要极力避免选到这些位置（否则后手必赢）。单个游戏，发现移动到 $(2,3),(3,2)$​​​​​​​ 时，先手必输。那么就可以定义 $SG(2,3) = SG(3,2) = 0$​​​​ ​​​而不是 $SG(1,1) = 0$​​​​​​​，事实上在转移的过程中需要避免上述三个区域。最后视为 $n$​​​​​​​ 个游戏，当 $n$​ ​​​​​​个棋子都在 $(2,3)||(3,2)$​​​​​​​​，则先手必输，依据 SG 定理异或一下就可以了。

### BZOJ 3576 HNOI 2014 江南乐

有 $n$​​​​​ 个石堆，每堆初始 $a_i$​​​​​ 个。给定定值 $F$​​​​​，每次可以操作一堆不小于 $F$​​​​​ 的石堆将其平均分成 $M$​​​​​ 堆（可知确定 $a_i,M$​​​​​，分的堆的状态唯一）。问博弈结果。

考虑 SG 定理后，对于每一堆易写出 SG 方程：$SG(a) = \operatorname{mex}\limits\limits_{M=2}^{a}\{\bigoplus\limits_{i=1}^{a\bmod M}SG(\frac{a}{M}+1)\bigoplus\limits_{i=1}^{M-a\bmod M}SG(\frac{a}{M})\},a\geq F$​

容易看出分奇偶贡献。问题在于复杂度仍比较高。由于遍历 $M$​ 作为 $\frac{a}{M}$​​ 的分母，考虑数论分块。

对于值相同的 $\frac{a}{M},a\bmod M = a - \frac{a}{M}*M,M - a\bmod M = M - a + \frac{a}{M}M = M(1 + \frac{a}{M})-a$​​​​​​​。当 $\frac{a}{M}$​​​​​ 为偶数时，$a\bmod M$​​​​ ​​​的奇偶性不改变；当 $\frac{a}{M}$​​​ ​​​​为奇数时，$M - a\bmod M$​​ ​​​​​的奇偶性不改变。基于这个，数论分块中只需枚举连续两个 $M$​​​​​​​ 即可计算出整块的贡献。复杂度为 $O(n\sqrt{n})$​​​​​​​

### AGC017d Game on Tree

发现一棵有根树的子树个数 $k>1$​，可看做 $k$ ​个独立的游戏，套个 SG 定理。

对于子树个数 $k=1$​​，有 $SG(T) = SG(T') + 1$​​。可用归纳法证。（不过这题我是靠人类智慧过的233

### HDU 4664 Triangulation

注意，初始凸形点是没有连线的。

写出 $s g(x)=\operatorname{mex}\{s g(i) \oplus s g(x-i-2)\}$​ ​后打表！是个 34 长度的循环节。

### HDU 5795 A simple Nim

可以取任意多石子，or 分成非空三堆，易写出 $sg$​​ ​方程，打表后可发现模 8 为 $7,0$​ ​​分别有 $SG(i) = i+1,SG(i) = i-1$​​​，其余 $SG(i) = i$​​​​。

### HDU 4764 Stone

可转化成取石子问题。由于是连续取数，转化为Bash博弈就是了。

### HDU 3951 Coin game

环上每次连续取若干硬币，问博弈结果。

环操作一次就拆成链了。在链上操作可以拆成一条或两条链。故先求出链的SG函数，之后求出环的SG函数。

发现当 $k=1,n=3,5,7,9,\dots$​​​，先手胜；$k=2$​​​ 必败；$k=3$​ ​​时当 $n\leq k$​​​ 必胜。

### CodeForces 768E Game of Stones

在每一堆里不能取之前取过的数。

在不考虑破坏SG定理的前提下，还是考虑（手动）打表。打表的过程中注意转移到的状态之后是比不能用对应数字的。可以发现 $sg(x) = n,\sum\limits_{i=1}^n i \leq x$ 的最大 $n$​。

### CodeForces 850C  Arpa and a game with Mojtaba

每次选一个素数 $p$​​​​ ​和幂次 $k$​​​​​ 使 $ n $​​​​​个数可以整除 $p^k $​ ​​​​的变为 $\frac{a_i}{p^k}$​​​​​。

发现将数按素数分解后，每个素数的幂次集间是独立的。故问题为幂次集间的 SG 异或和。

对于每个幂次集 $b_i$​​​，每次选不大于 $\max\{b_i\} $​​ ​的数 $q$​​​，小于 $q$​ ​​的不变，大于等于 $q$​ ​​​的 `-=q`。则对于幂次集来说可以用状压优化。具体的可以写成 `st = (st << q) | (st & (1<<(q-1))-1) `，之后 dfs 求对应状态的 SG 值即可（太妙了。。自己暴力写的 vector 存的状态）

### CodeForces 603C Lieges of Legendre

有 $n$​ 堆石子，每堆 $a_i$​ 个。每次可以在一堆石子里拿一个，or 当 $a_i$​ 为偶数时分成 $k$​ 堆 $\frac{a_i}{2}$​ 的石子。问博弈结果。

明显 $n$ 堆互不影响。

对于单堆，如果是偶数就可以分成 $k$ 堆。易发现当 $k$ 为偶数时，$SG(2x) \rightarrow \bigoplus\limits_{i=1}^k SG(x) = 0$；当 $k$ 为奇数，$SG(2x) \rightarrow SG(x)$。故按 $k$ 的奇偶进行讨论。

$k$​ 为奇：$SG(2x) = \operatorname{mex}\{SG(x),SG(2x-1)\},SG(2x+1) = \operatorname{mex}\{SG(2x)\}$​。打表发现$SG(2x+1) = 0,x\geq 2$​，故 $SG(2x)$​ 可以 $\log$​ 递归处理。

$ k$​ 为偶：类似的分析方法。

### HDU 6105Gameia

由于 A 先行，故每次可在叶节点的父节点（下称其为二级点）填白，此时 B 必只能在叶节点填黑，否则轮到A放到叶节点上则一直会有白点。基于此往完美匹配方向去想。

◦ 如果不存在完美匹配，那么 A 从树叶开始，每次都染树叶父节点，那么 B 就被迫染叶子。
因为 B 染叶子不会改变局势，且图不存在完美匹配，总存在一个时刻，A 染到了一个周
围已被染色的孤立点。这时候 B 就输了。

◦ 如果存在完美匹配，但是 B 小动作不足以将这个树分成点对，那么：

◦ 如果一个节点有多于一个叶子，那么 B 显然已经输了。

◦ 否则，找到一个叶子，其父节点只有一个儿子，A 染色之。

◦ 这时候，B 会被迫染这个父节点，但是这个父节点有连带影响，使得未染色点为奇数。

◦ 当未染色点为奇数时，即不存在完美匹配，B 必须通过小动作切断树边阻止这样的影响。

◦ 当B的小动作不够时，B 就输了。

### HDU 4701 Game

题目大意是：有 N 个物品，每个物品有 Ci 个价值，ALICE 和 BOB 分别有 A, B 元钱，依次购买（即买第 i 个物品前 i-1 物品必须买完），直到有一人无法购买。问 ALICE 是否有必胜策略。

见到这类型题，直接往 dp 方向去想（dp 暗示很明显）。

虽然是博弈，但以当选中第 $i$​​​ 个物品时，此时仅跟在此刻先手的人的 money 有关。故定义状态 $dp(i)$​ ​​为在选物品 $i$​​​ 时能够胜利的最少钱数。设总钱数为 tot，则前缀和小于等于 tot 的最大下标 $id$​​​ 即为能买到的最后一件商品（后面的商品压根买不到所以跟博弈状态无关）。易知 $dp(id) = c_{id}$​​​​​。

考虑前面一格状态：如果 $i,i+1$ ​均为同一个人买，此时在状态 $i$​ 即为必胜态。故有 $dp(i) = dp(i+1) + c_i$​​；

而 $i,i+1$​​​​ 的物品为两个人买，此时需要先手买完 $i$​​​ ​后使对手处于必败态，在上述状态定义即让对手在选 $i+1$​​​​ 时的钱数小于 $dp(i+1)$​​​​。

设 $i+1$​​ ​​时对手有 $b$​ ​​​钱，$b < dp(i+1)\rightarrow tot - \sum\limits_{j=1}^{i-1}c_j - a<dp(i+1),a$​ ​​​为状态 $i$​ ​​​时先手有的钱。

故可得 $a \geq tot - \sum\limits_{j=1}^{i-1}c_j - dp(i+1) + 1$​​​​，可知状态 $i$​​​​ 在此决策至少要有不等式右侧的钱。

故$dp(i) = \min(dp(i+1)+c_i,tot - \sum\limits_{j=1}^{i-1}c_j - dp(i+1) + 1)$​​​​​​​​

### AGC014d Black and White Tree

跟 Gameia 类似的结论：当存在完美匹配$\iff$​​后手赢。

充分性：当存在完美匹配，不论白填哪，按匹配对点另一个点就赢。

必要性：如果不存在完美匹配，此时白每次都填二级节点，可以发现最后一定有个孤立点，周围都是白点。

### AGC010d Decrementing

对必败态的描述很重要。从数的数量，奇偶上考虑。

必败态为全1。由于除的是公约数，又由于质因子2比较特殊（-1可以奇偶转变），此时从数的奇偶个数考虑。

由于初始 gcd=1，即至少有一个奇数。当先手时有奇个偶数，就将其转成偶个偶数（又多一个奇数）。后手翻奇数时有奇个偶数（且此时至少一个奇数），后面的先手再翻回来；后手翻偶数时，此时至少三个奇数，后面的先手同样可以回到最初必胜态。由于保证每次的状态都至少一个奇数，此时约去的最大公约数必不包含 2。

但如果先手时偶个偶数：如果去翻偶数，转为了对方的必胜态；如果此时奇数个数 >1 且去翻奇数，还是转为对方必胜态。而若此时恰好一个奇数且 >1，翻了他后就情况不一定了（此时 gcd 必包含质因子 2）。这时候递归求解就行，复杂度 $O(n\log n)$​​。

### AGC002e Candy Piles

这道题一次消去一行或最高的一列：尝试转化成步数模型。

![](C:\Users\Kinesis\Desktop\markdown图片\博弈论和sg函数1.png)

设当前处在 $(1,1)$ ​节点，一旦走到边界外就是必败态。对图进行 SG 递推可以求得 $(1,1)$ ​的 SG 函数。不过复杂度过高。

![](C:\Users\Kinesis\Desktop\markdown图片\image-20201115205351973.png)

试求必胜必败态，可以发现每个对角线的状态都是一致的（可以简单分情况证明）。那么只需要走到非边界点，然后往上往右走。如果上和右的步数均为奇数，此时必败（具体自己可以画画）。

### AGC016f Games on DAG

给定一个 DAG，1号、2号点上有 1 个棋子，A,B 轮流玩游戏，每轮可以选择将 u 上的棋子通过一条边移动到 v 上，无法移动者输。求这个 DAG 的所有子图（任意删去边，共 2m 个）中满足先手必胜的数量。N<=15。

首先两个石子在图上推，由 SG 定理可知当两点 SG 值不同时先手必胜。明显考虑反面情况易做，即当考虑当前图使两点 SG 值相同。

数据范围很适合枚举图的点集及其子集。令 $f(V)$​​ 为当前点集为 $V$​​ 时，满足两点 SG 值相同的方案数。如果将点集按 SG=0，SG$\neq$​​0 来划分（分别为 $T,U$​​），由 SG 的定义可知：

- U 的每个点至少要指向一个T的点。
- T 的内部无点相连。
- T 到 U 随便连。

对于当前点的状态 $V = T + U$​ 来说，两个点要不在 T，要不在 U。而当两个点在 U 时，U 中的连边情况就为 $f(U)$​（$T$​ 的点集只是把 $U$​​​ 中点集 SG 值 +1，可以视作 SG 的分层图）。只要保证枚举时两个点的状态一致，按上述三点来贡献值就行了。（对于两个点在 T，实际上就是一直都在 SG=0 的图，对于最终的点集，实际 T 就是点集的子集。即计算顺序跟在 U 不同）
