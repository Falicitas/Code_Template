

# 类欧几里得

用于$O(logn)$计算$f(a,b,c,n) = \sum\limits^{n}_{i=0}\lfloor\frac{ai+b}{c}\rfloor$，算法的流程类似欧几里得交换分子与分母并取模，由此推导出复杂度。

## 算法流程及证明

$[1]:$当$a\geq c\ or\ b\geq c$时，$\\\lfloor\frac{ai+b}{c}\rfloor = \lfloor\frac{(\lfloor\frac{a}{c}\rfloor*c+a\%c)i+(\lfloor\frac{b}{c}\rfloor*c+b\%c)}{c}\rfloor = \lfloor\frac{a}{c}\rfloor*i + \lfloor\frac{b}{c}\rfloor + \lfloor\frac{(a\%c)i+(b\%c)}{c}\rfloor.\\$即$f(a,b,c,n) = \frac{n(n+1)}{2}\lfloor\frac{a}{c}\rfloor+(n+1)\lfloor\frac{b}{c}\rfloor+\sum\limits^{n}_{i=0}\lfloor\frac{(a\%c)i+(b\%c)}{c}\rfloor$，转化至$a<c\ and\ b<c$

$[2]:$当$a<c\ and\ b<c$时，贡献与条件转化，得$\sum\limits^{n}_{i=0}\lfloor\frac{ai+b}{c}\rfloor = \sum\limits^{n}_{i=0}\sum\limits^{\lfloor\frac{ai+b}{c}\rfloor-1}_{j=0} 1 $，上限受一维约束，转化遍历顺序，得$\sum\limits^{\lfloor\frac{an+b}{c}\rfloor-1}_{j=0}\sum\limits^{n}_{i=0} [j<\lfloor\frac{ai+b}{c}\rfloor].$

对于$j<\lfloor\frac{ai+b}{c}\rfloor \Leftrightarrow j+1\leq\lfloor\frac{ai+b}{c}\rfloor\Leftrightarrow j+1\leq \frac{ai+b}{c}\Leftrightarrow j*c + c\leq a*i+b$
$\Leftrightarrow j*c+c-b-1 <a*i\Leftrightarrow \lfloor\frac{j*c+c-b-1}{a}\rfloor <i$，基于整除原理、、

则原式为$\sum\limits^{\lfloor\frac{an+b}{c}\rfloor-1}_{j=0}\sum\limits^{n}_{i=0} [i>\lfloor\frac{j*c+c-b-1}{a}\rfloor] = \sum\limits^{\lfloor\frac{an+b}{c}\rfloor-1}_{j=0}(n+1 - \lfloor\frac{j*c+c-b-1}{a}\rfloor - 1) = \sum\limits^{\lfloor\frac{an+b}{c}\rfloor-1}_{j=0}(n- \lfloor\frac{j*c+c-b-1}{a}\rfloor)$、、令$m = \lfloor\frac{an+b}{c}\rfloor$，则$f(a,b,c,n) = \sum\limits^{m-1}_{j=0}n-\sum\limits^{m-1}_{j=0}\lfloor\frac{j*c+c-b-1}{a}\rfloor = mn- f(c,c-b-1,a,m-1)$

由于分母分子对调，并以分母做取模运算，由gcd复杂度推出递推复杂度为$O(logn)$

## 扩展 g 和 h

两个变式：

$g(a, b, c, n)=\sum_{i=0}^{n} i\left\lfloor\frac{a i+b}{c}\right\rfloor,h(a, b, c, n)=\sum_{i=0}^{n}\left\lfloor\frac{a i+b}{c}\right\rfloor^{2}$​

基于类欧原理都可推得、、放推到过程：

### g

$[1]:a>c\ or\ b>c,$$g(a, b, c, n)=g(a \bmod c, b \bmod c, c, n)+\left\lfloor\frac{a}{c}\right\rfloor \frac{n(n+1)(2 n+1)}{6}+\left\lfloor\frac{b}{c}\right\rfloor \frac{n(n+1)}{2}$

$[2]:a<c\ and\ b<c,$令$m=\left\lfloor\frac{a n+b}{c}\right\rfloor,$

\begin{array}{l}
g(a, b, c, n)=\sum_{i=0}^{n} i\left\lfloor\frac{a i+b}{c}\right\rfloor \\
=\sum_{j=0}^{m-1} \sum_{i=0}^{n}\left[j<\left\lfloor\frac{a i+b}{c}\right\rfloor\right] \cdot i
\end{array}

令$t=\left\lfloor\frac{j c+c-b-1}{a}\right\rfloor,$原式

\begin{array}{l}
=\sum_{j=0}^{m-1} \sum_{i=0}^{n}[i>t] \cdot i \\
=\sum_{j=0}^{m-1} \frac{1}{2}(t+n+1)(n-t) \\
=\frac{1}{2}\left[m n(n+1)-\sum_{j=0}^{m-1} t^{2}-\sum_{j=0}^{m-1} t\right] \\
=\frac{1}{2}[m n(n+1)-h(c, c-b-1, a, m-1)-f(c, c-b-1, a, m-1)]
\end{array}

### h

$[1]:a>c\ or\ b>c,$
$h(a, b, c, n) =h(a \bmod c, b \bmod c, c, n)$ $+2\left\lfloor\frac{b}{c}\right\rfloor f(a \bmod c, b \bmod c, c, n)$ $+2\left\lfloor\frac{a}{c}\right\rfloor g(a \bmod c, b \bmod c, c, n)$ $+\left\lfloor\frac{a}{c}\right\rfloor^{2} \frac{n(n+1)(2 n+1)}{6}+\left\lfloor\frac{b}{c}\right\rfloor^{2}(n+1)+\left\lfloor\frac{a}{c}\right\rfloor\left\lfloor\frac{b}{c}\right\rfloor n(n+1)$（这个下取整的a/c渲染的有点难看。。怪a长得矮、、）

$[2]:a<c\ and\ b<c,$
令$m=\left\lfloor\frac{a n+b}{c}\right\rfloor,t=\left\lfloor\frac{j c+c-b-1}{a}\right\rfloor,$

在贡献与条件转化时不希望出现$\sum\limits^{{\left\lfloor x\right\rfloor}^2}$的情况，利用$n^2 = 2*\frac{n(n+1)}{2} - n = 2*\sum\limits^{n}_{i=1}i-n$，原式为$\left\lfloor\frac{a i+b}{c}\right\rfloor^{2} = 2*\sum\limits^{\left\lfloor\frac{a i+b}{c}\right\rfloor}_{i=1}i-\left\lfloor\frac{a i+b}{c}\right\rfloor$

故$h(a, b, c, n)=\sum\limits_{i=0}^{n}\left\lfloor\frac{a i+b}{c}\right\rfloor^{2}=\sum\limits_{i=0}^{n}\left[\left(2 \sum\limits_{j=1}^{\left\lfloor\frac{a i+b}{c}\right\rfloor} j\right)-\left\lfloor\frac{a i+b}{c}\right\rfloor\right]=\left(2 \sum\limits_{i=0}^{n} \sum\limits_{j=1}^{\left\lfloor\frac{a i+b}{c}\right\rfloor} j\right)-f(a, b, c, n)$

前面一项化简：

\begin{aligned}
& \sum_{i=0}^{n} \sum_{j=1}^{\left\lfloor\frac{a i+b}{c}\right\rfloor} j \\
=& \sum_{i=0}^{n} \sum_{j=0}^{\left\lfloor\frac{a i+b}{c}\right\rfloor-1} (j+1) \\
=& \sum_{j=0}^{m-1}(j+1) \sum_{i=0}^{n}\left[j<\left\lfloor\frac{a i+b}{c}\right\rfloor\right] \\
=& \sum_{j=0}^{m-1}(j+1) \sum_{i=0}^{n}[i>t] \\
=& \sum_{j=0}^{m-1}(j+1)(n-t) \\
=& \frac{1}{2} n m(m+1)-\sum_{j=0}^{m-1}(j+1)\left\lfloor\frac{j c+c-b-1}{a}\right\rfloor \\
=& \frac{1}{2} n m(m+1)-g(c, c-b-1, a, m-1)-f(c, c-b-1, a, m-1)
\end{aligned}

因此$h(a, b, c, n)=n m(m+1)-2 g(c, c-b-1, a, m-1)-2 f(c, c-b-1, a, m-1)-f(a, b, c, n)$

## 代码

由于三个函数交叉迭代，而迭代的状态均相同，整合至一个数据块求解，，

```cpp
namespace class_gcd
{
    const int P = 998244353;
    int i2 = 499122177, i6 = 166374059;//模数不同另算逆元
    struct data {
        int f, g, h;
        data() {f = g = h = 0;}
    };  // 三个函数打包
    data calc(int n, int a, int b, int c) {
        int ac = a / c, bc = b / c, m = (a * n + b) / c, n1 = n + 1, n21 = n * 2 + 1;
        data d;
        if (a == 0) {  // 迭代到最底层
            d.f = bc * n1 % P;
            d.g = bc * n % P * n1 % P * i2 % P;
            d.h = bc * bc % P * n1 % P;
            return d;
        }
        if (a >= c || b >= c) {  // 取模
            d.f = n * n1 % P * i2 % P * ac % P + bc * n1 % P;
            d.g = ac * n % P * n1 % P * n21 % P * i6 % P + bc * n % P * n1 % P * i2 % P;
            d.h = ac * ac % P * n % P * n1 % P * n21 % P * i6 % P + bc * bc % P * n1 % P + ac * bc % P * n % P * n1 % P;
            d.f %= P, d.g %= P, d.h %= P;

            data e = calc(n, a % c, b % c, c);  // 迭代

            d.h += e.h + 2 * bc % P * e.f % P + 2 * ac % P * e.g % P;
            d.g += e.g, d.f += e.f;
            d.f %= P, d.g %= P, d.h %= P;
            return d;
        }
        data e = calc(m - 1, c, c - b - 1, a);
        d.f = n * m % P - e.f, d.f = (d.f % P + P) % P;
        d.g = m * n % P * n1 % P - e.h - e.f, d.g = (d.g * i2 % P + P) % P;
        d.h = n * m % P * (m + 1) % P - 2 * e.g - 2 * e.f - d.f;
        d.h = (d.h % P + P) % P;
        return d;
    }
}
```

## 总结

类欧基于整除、贡献与条件转化、平方转求和、欧几里得、整数除模拆分$(a=\left\lfloor\frac{a}{c}\right\rfloor*c+a\%c)$等基本原理、、不知道怎么出题。。但掌握原理，也能推出点东西8

单求$f$的话根据上文稍微改改、、虽然觉得不太可能出这么裸