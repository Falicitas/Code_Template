# 线性基

一种可用来解决异或问题的 **数据结构** 。

大抵是希望构造一个集合，集合里的数仅通过异或操作可以还原原集合。从这个问题下手，就可以根据原集合，按位来构造一个线性基了。

## 插入与判定

线性基的第i位存储着以第i位为最高位的数字。

对于插入，要是当前数的最高位为i且当前的位置为空（a[i]=0），此时a[i] = 该数；否则该数 *异或a[i]* ，继续往下找。直至找到位置，或者这个数为0。

考虑这个过程，如果一个数走到了0，说明存在一种异或的数集合，使异或结果等于该数。对于没有走到0的，就存储着该数本身。所以对于一个集合这样操作，就实现了求得的线性基能能通过异或表示原数集的每个数。

```cpp
void ins(ll x){
    for(reg int i=MN;~i;i--)
        if(x&(1ll<<i))
            if(!a[i]){a[i]=x;return;}
            else x^=a[i];
    flag=true;
}
bool check(ll x){
    for(reg int i=MN;~i;i--)
        if(x&(1ll<<i))
            if(!a[i])return false;
            else x^=a[i];
    return true;
}
```

## 查询异或最值

对于最小值：由于线性基上存储的数可由原集合异或得到，故取线性基里的最小值。发现不管与其他的线性基里的元素异或都会增大其值，故最小值就是线性基里的最小值。 **如果原集合有两个数及以上相同的，那直接为0。** 

对于最大值：直接贪心。当前数的第i位要是为0，要是线性基第i位有值就异或，答案不会变差。

## 查询异或第k小

异或第k大反过来做。

考虑一种最简单的情况：当线性基的每一位均为$2^i$的形式，那么线性基就可以表示（假设有$[0,L]$的值）$2^{L+1}$个数的数。

遵循上面的方法，只要把原本的线性基简化一波，即对于值域内的每一位$i$，都只会在$a_i$中出现（即对于其他的$a_j$，第i位均为0）那么对于第i位到底能否决定值0/1，仅取决于线性基第i位有无值。

由于不能不选，对于0要特判一下。

结合上面的，一共有如下代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
using i64 = long long;
using u64 = unsigned long long;

struct Linear_base {
    vector<u64> lb;
    Linear_base() {
        lb = vector<u64>(64);
    }
    void insert(u64 x) {
        for (int i = 63; i >= 0; i--) {
            if (x & (1ull << i)) {
                if (!lb[i]) {
                    lb[i] = x;
                    return;
                } else {
                    x ^= lb[i];
                }
            }
        }
    }
    bool check(u64 x) {  //查看是否存在在一个子集，使异或和为x
        for (int i = 63; i >= 0; i--) {
            if (x & (1ull << i)) {
                if (!lb[i]) {
                    return false;
                } else {
                    x ^= lb[i];
                }
            }
        }
        return true;
    }
    u64 qmax() {
        u64 res = 0;
        for (int i = 63; i >= 0; i--) {
            res = max(res, res ^ lb[i]);
            return res;
        }
    }
    u64 qmin() {
        for (int i = 0; i <= 63; i++) {
            if (lb[i]) {
                return lb[i];
            }
        }
    }

    //剩个找第k大
};

```

