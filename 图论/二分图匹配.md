# 二分图 & 二分图匹配

## 成为二分图的充分必要条件

当且仅当至少有两个节点且不存在奇环（是奇环的话，黑白染色一波就会冲突）。

判定方法：黑白染色。

- 若动态连边判断是否构成二分图，则拆点后将<A黑,B白>,<A白,B黑>放入 **并查集** 。每次连边判断连的两个点对应的对偶点是否在同一集合里（比如A黑和A白是否在同一集合），若是，则不构成二分图。

## 匈牙利算法

每次去找一条増广路（不包含环，故不能访问当前匹配时已经访问的点）去连边。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

struct Hungary {  //点集范围[0,n-1]
    vector<vector<int>> e;
    vector<int> left, link, vis;
    int n;
    Hungary(vector<vector<int>> e_, vector<int> left_)
        : e(e_), left(left_) {
        n = e.size();
        link = vector<int>(n), vis = link;
    }
    int dfs(int u) {
        for (auto v : e[u]) {
            if (vis[v]) {
                continue;
            }  //当前匹配时已经访问过了，再访问会形成环，不是増广路
            vis[v] = 1;
            if (!link[v] || dfs(link[v])) {  //去让之前匹配v的点u'找其他的匹配
                link[v] = u;
                return 1;  //匹配上一条
            }
        }
        return 0;
    }
    vector<int> hungary() {
        int match = 0;
        for (auto u : left) {      //枚举其中一个点集
            vis = vector<int>(n);  //缺省当前另外点集均无访问过
            match += dfs(u);
        }
        return link;
    }
};

int main() {
    vector<vector<int>> e;
    vector<int> left;
    Hungary hg(e, left);
    vector<int> link = hg.hungary();
    return 0;
}
```

## KM算法

首先要明确的是，需要构造一个“完美匹配”（即共有n对点。实际上只需要其中一个点集所有的点都配上就可以了）。所以缺点就补虚点，缺边补边权为0的虚边。若原边集中有负权边，全变成非负权边后再来运算。

定义 **有效边** ：给每个点设一个 **顶标** （类似点权），左侧点集的顶标初始设为相连的最大边权，右侧点集则设为0。有效边的定义则是：当且仅当一个边的两个点顶标和等于当前边。感性理解就是，有向边是优先选择的匹配边，否则通过降低标准（左顶标的值）使其他边也能成为有效边。

对于当前匹配的点，当当前的有效边不能构成増广路时，给不完整増广路上的节点打上标记，找到最小降低标准 $\delta$​ ，此时左点集顶标$-\delta$​，右点集顶标$+\delta$​，此时之前的有效边还会是有效边，同时会加入其他的降低标准的有效边进来以试图找到新的増广路。

```cpp
#include <bits/stdc++.h>
using namespace std;

using i64 = long long;
struct KM {  //求最小完美匹配的板子。求最大完美匹配，将边权矩阵取负即可。对于边数=O(n^2)，快过费用流
    const i64 inf = 0x3f3f3f3f3f3f3f3f;
    vector<vector<i64>> w;
    int n, m;
    KM(int n_, int m_, vector<vector<i64>> w_)
        : n(n_), m(max(m_, n_)), w(w_) {
    }  //w[i][j]指左点集i与右点集j的权值。左点集大小为n，右点集大小为m
    i64 km() {
        std::vector<i64> u(n + 1), v(m + 1), p(m + 1), way(m + 1);
        for (int i = 1; i <= n; i++) {
            p[0] = i;
            i64 j0 = 0;
            std::vector<i64> minv(m + 1, inf);
            std::vector<char> used(m + 1, false);
            do {
                used[j0] = true;
                i64 i0 = p[j0], delta = inf, j1;
                for (int j = 1; j <= m; ++j) {
                    if (!used[j]) {
                        i64 cur = w[i0][j] - u[i0] - v[j];
                        if (cur < minv[j]) {
                            minv[j] = cur, way[j] = j0;
                        }
                        if (minv[j] < delta) {
                            delta = minv[j], j1 = j;
                        }
                    }
                }
                for (int j = 0; j <= m; ++j) {
                    if (used[j]) {
                        u[p[j]] += delta, v[j] -= delta;
                    } else {
                        minv[j] -= delta;
                    }
                }
                j0 = j1;
            } while (p[j0] != 0);
            do {
                i64 j1 = way[j0];
                p[j0] = p[j1];
                j0 = j1;
            } while (j0);
        }
        i64 res = 0;
        for (int i = 1; i <= m; i++) {
            res += w[p[i]][i];
        }
        return res;
    }
};
```

## Hall定理

对于一个二分图，若左点集任选一个子集$S$，其连到右点集的点集集合$T$均满足$|T|\geq |S|$，则该图必有完美匹配（至少对于左点集来说）。（充要）

必要性：假设有完美匹配，又不满足Hall定理，则必有一个点是孤寡点，此时不满足完美匹配，与假设矛盾。

充分性：假设满足Hall且不是完美匹配。

那么在找出最大匹配的方案之后, 可以找到至少一个末被匹配的点a。（左点集的）

因为满足Hall定理, 所以a一定连向了至少一个点b, 如果这个b不在最大匹配中, 就匹配上了；否则b肯定在最大匹配中，此时一定有一个点c和它匹配了。这个点又一定连向了除它匹配的点外的至少一个点d...最后定能找到一条増广路使最大匹配+1，与假设矛盾。

## 最小点覆盖 & 最小边覆盖

最小点覆盖 = 最大匹配（<=、>=证。<=依据不完整増广路来证明）

最小边覆盖 = n - 最大匹配（贪心证）

证明一下最小点覆盖。

对于 >= 的情况，最大匹配的边都至少要一个点来覆盖，故证得。

对于 <= 的情况，遍历右点集没匹配的点，找能匹配但没匹配上的左点集。左点集以**已匹配边**连向右点集。此时会走出若干不完整増广路（如果走出完整増广路，意味着原图不是最大匹配，与前提矛盾）可知被选上的左点集的点可以覆盖包括未匹配的右点集的被标记的点。那么与该结构类似的，没被选上且已被匹配的右点集的点可以覆盖包括未匹配的左点集的没被标记的点。那恰好选出来的点的数量为最大匹配数，所以 <= 得证。

## 一些习题

### CF741C Arpa’s overnight party and Mehrdad’s silent entering

有 2n 个人围成一圈坐在桌子边上，每个人占据一个位子，对应这 2n 个人是 n 对情侣，要求情侣不能吃同一种食物，并且桌子上相邻的三个人的食物必须有两个人是不同的，只有两种食物（1 或者是2），问一种可行分配方式。

经验丰富的选手看到构造可行解，率先让相邻的两个 $2*i-1,2*i$​ 节点挨在一块连边，让彼此不能吃同样的食物，此时任意三人必有两人吃不同的食物。然后将情侣连边。由于情侣是一对一对的，若出现环必然是偶环，所以能构造出解来。

### [ZJOI2007] 矩阵游戏

经验丰富的选手，考虑斜对角线上有黑点，即 $(i,i)$​ 处均为黑点。网格图考虑按行列建点集，发现两个列/行交换不影响匹配结果（但实际含义，即换行，发生了变化）。答案就是最大匹配。

### 多米诺覆盖

经典水题。黑白染色然后跑二分图。

### 多米诺覆盖2

网格图上有障碍，问用最少的骨牌覆盖所有的非障碍点。

先尽量多的放骨牌，最后再单独放。实际求得是最小边覆盖。

### CF387D George and Interesting Graph

直接枚举中心点，处理完中心点的增边删边后，删除中心点，即剩余点每个点入度为 1，出度为 1。这样的图是若干个环构成的。

将点拆成入点和出点，共 2n-2 个点。对于未能能匹配上的节点 2*n' 两两连边，共需增 n' 条边。剩余的，大于匹配数的边需要删边。完成。

**对于环，拆点后是二分图完美匹配。**

### Gym 101873F Plug It In

题意：有 m 个插座, n 个电器, 每个插座最多可连接一个电器。另外有一个插线板, 可以使得一个插座连接三个电器, 给出每个插座能插的电器, 问最多能插电器的个数是多少。

首先原图跑个最大匹配没问题吧。考虑枚举插线板安装在哪个插座上，只需要对跑完的图在跑两次増广路即可。即每次把跑完的图复制一份，然后跑新增点的増广路即可。

### CF981F Round Marriage

Hall 定理的经典题目。

这道题的细节。

![Round Marriage](C:\Users\Kinesis\Desktop\markdown图片\Round Marriage.png)



