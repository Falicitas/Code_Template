# 网络流

网络流指，在一张有且仅有一个源点 S，有且仅有一个汇点 T，边权代表最大能容纳多少流量的图上，进行运算的算法。

网络流的流量很适合表征 **限制**。串联类似于乘法原则，是分步完成事件的抽象描述；并联则是类似于加法原则，是不同步骤完成事件的抽象描述。

## 流量网络 & 残留网络

定义 $c_f<u,v> = c<u,v> - f<u,v>$，$f$ 为流量，$c$ 为容量，$c_f$ 为残余容量。

**残余容量 + 反向平衡的流量** 构成了残留网络。

## dinic

分层次来找増广路，每次可实现找多条増广路，且尽量走短的边（能走短的増广路肯定就走短的吧，走完短的，很多长的増广路可能就已经失效了。这里考虑走最短用的时间少，且如果反悔贪心是正确的，那么先走短的再走长的也没问题）。

**当前弧优化** 

对于链式前向星储存图，先遍历的边总会被优先加载更多的流量。而对于当前分层图，已经跑满了的边，若重复跑边是很浪费时间的。

具体举两个例子，感受一下：

> S→A有1e5条容量1的边，
> A→T有1e5条容量1的边
>
> S→A有1e5条容量1的边，
> A→T有1条容量1e5的边

对于这种边结构，再搞复杂一点，就被卡死了。

那么只需要不再遍历这些满流边即可。

用cur来存储当前能遍历的边（不能遍历的 **必然是满流边** ）。每次分层时重新给cur赋值。

对于提供的流量不比当前边的容量大时，由于 flow=0，跳出了循环，故下次还会遍历这条边。不然 flow 必然大于当前边的容量，使边满流，那么这时就再也不会遍历这条边了。实现了优化。

## 最小割

对于S，T，将其两个的流量网络彻底断开所耗费的流量称作 **割** ，其中流量耗费最小的是 **最小割** 。

最小割等于最大流。不太想写证明。

最小割问题，有取最小或取最大问题。对于取最大，先~~做白日梦？~~取完所有有收益的，然后建失去收益的边。求出来的即是最小代价，减去后即为最大收益。

注意，最小割，割去的是边，而这个边是来自于对边的定义。所以在做最小割建图，关注点应该在如何定义这条失去收益的边。

## Ford - Fulkson方法

指从源点到汇点，每次找一条増广路进行扩流，直到不存在増广路为止。dinic，ISAP，以及最小费用最大流均基于此方法稍作改进得来。

## 删点操作

这里提到的删点，并不是一个算法。当建出来的图复杂度过高的时候，去考虑哪些点能删除，或者合并，以保证最后建出来的图是满足复杂度要求的。

可以删除的点：没有流出的流量，或者没有流入的流量。

可以合并的点：两个点 <u,v> 的容量为 inf，且 v 没有其他的流量来源，此时 u，v 视为一个点。

两个点的来源相同，即连向他俩的点一样，且容量相同，此时可以合并成一个点，且容量翻倍。

两个点的去向相同，即连出的点一样，且容量相同，此时可以合并成一个点，且容量翻倍。

## 最大权闭合子图

其实就是最小割的应用。对于一个图的点，有正权有负权，每次选一个点，与其可到达的所有点都得被选上，问图的最大权方案。

假设正权点都选了，那么不选最大权需要支付费用；（可能被迫）选了负权点，需要支付费用。于是原图的所有边容量为 inf，S 向正权点连点权容量的边，负权点向 T 连负点权容量的边，跑个最小割即为答案。

## 有上下界的网络流

一些边至少流满 xx 流量，至多流满 yy 流量的模型。

对于这种模型，在原图保留上界 R 减下界 L 的边，然后对于任意一条有向边 <u,v>，点 u 的顶标 -L，点 v 的顶标 +L。

对于包括源点 S 汇点 T 的点，当顶标 >=0，超级源 SS 向点 u 连顶标值大小流量的边。当顶标 <0，u 向超级汇 TT 连顶标值的绝对值流量的边。

先跑一遍 dinic(SS,TT)，然后连接 <T,S,inf>，再跑一次 dinic(SS,TT)，此时 T->S 的反边就是最小流。

之后去除 T->S 这条边，然后跑 dinic(S,T)（由于原图可能没跑满），最大流就等于最小流加上 dinic(S,T) 的值了。

画图能感性理解正确性。

## 代码

### dinic

```cpp
//加了弧优化
struct E {
    int v, c, next;
} edge[M];
int p[N], cur[N], eid, d[N], q[N], s, t;

void link1(int u, int v, int c) {
    edge[eid].v = v, edge[eid].c = c, edge[eid].next = p[u], p[u] = eid++;
}
void link2(int u, int v, int c) {
    link1(u, v, c), link1(v, u, 0);
}

bool makelevel()  //广搜标号
{
    memset(d, 0, sizeof d);
    d[s] = 1;
    int l = 0, r = 0;  //手写队列的指针
    q[r++] = s;
    while (l < r) {
        int u = q[l++];
        if (u == t)
            return true;  //可达汇点
        UREP(i, u) {
            int v = edge[i].v;
            if (!d[v] && edge[i].c)
                q[r++] = v, d[v] = d[u] + 1;
        }
    }
    return false;
}

int dfs(int u, int flow) {
    if (u == t || !flow)
        return flow;
    int sum = 0;
    for (int& i = cur[u]; i + 1; i = edge[i].next) {  //弧优化，表示每次删掉邻接表靠后加入的边（表示这些边已经跑满了，不需要再访问）
        int v = edge[i].v;
        if (edge[i].c && d[v] == d[u] + 1) {
            int tmp = dfs(v, min(edge[i].c, flow));
            edge[i].c -= tmp, edge[i ^ 1].c += tmp;
            flow -= tmp;
            sum += tmp;
            if (!flow)
                break;
        }
    }
    if (sum == 0)
        d[u] = -1;  //表示这个点无法放流量了就在此回合屏蔽掉
    return sum;
}

int dinic() {
    int ans = 0;
    while (makelevel()) {
        memcpy(cur, p, sizeof cur);
        ans += dfs(s, inf);
    }
    return ans;
}
```

### 最小费用最大流

```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int N = 5e3 + 5, M = 1e5 + 5;
constexpr int INF = 0x3f3f3f3f;
int n, m, tot = 1, lnk[N], cur[N], ter[M], nxt[M], cap[M], cost[M], dis[N], ret;
bool vis[N];

void add(int u, int v, int w, int c) {
    ter[++tot] = v, nxt[tot] = lnk[u], lnk[u] = tot, cap[tot] = w, cost[tot] = c;
}
void addedge(int u, int v, int w, int c) {
    add(u, v, w, c), add(v, u, 0, -c);
}
bool spfa(int s, int t) {
    memset(dis, 0x3f, sizeof(dis));
    memcpy(cur, lnk, sizeof(lnk));
    std::queue<int> q;
    q.push(s), dis[s] = 0, vis[s] = 1;
    while (!q.empty()) {
        int u = q.front();
        q.pop(), vis[u] = 0;
        for (int i = lnk[u]; i; i = nxt[i]) {
            int v = ter[i];
            if (cap[i] && dis[v] > dis[u] + cost[i]) {
                dis[v] = dis[u] + cost[i];
                if (!vis[v])
                    q.push(v), vis[v] = 1;
            }
        }
    }
    return dis[t] != INF;
}
int dfs(int u, int t, int flow) {
    if (u == t)
        return flow;
    vis[u] = 1;
    int ans = 0;
    for (int& i = cur[u]; i && ans < flow; i = nxt[i]) {
        int v = ter[i];
        if (!vis[v] && cap[i] && dis[v] == dis[u] + cost[i]) {
            int x = dfs(v, t, std::min(cap[i], flow - ans));
            if (x)
                ret += x * cost[i], cap[i] -= x, cap[i ^ 1] += x, ans += x;
        }
    }
    vis[u] = 0;
    return ans;
}
int mcmf(int s, int t) {
    int ans = 0;
    while (spfa(s, t)) {
        int x;
        while ((x = dfs(s, t, INF)))
            ans += x;
    }
    return ans;
}
int main() {
    int s, t;
    cin >> n >> m >> s >> t;
    while (m--) {
        int u, v, w, c;
        cin >> u >> v >> w >> c;
        addedge(u, v, w, c);
    }
    int ans = mcmf(s, t);
    cout << ans << " " << ret << "\n";  //ret为费用
    //ret = 0;//ret是全局，需要清空
    return 0;
}
```

### 有上下界网络流

```cpp
//code sourced from kinesis
#include <bits/stdc++.h>
using namespace std;
using i64 = long long;
using pii = pair<i64, i64>;
constexpr int N = 6e4 + 10, M = 1e6 + 5;
constexpr i64 inf = 0x3f3f3f3f3f3f3f3f;
struct E {
    int v, next;
    i64 c;
} edge[M];
int p[N], cur[N], eid, d[N], q[N], SS = N - 1, TT = N - 2, S, T;

void link1(int u, int v, i64 c) {
    edge[eid].v = v, edge[eid].c = c, edge[eid].next = p[u], p[u] = eid++;
}
void link2(int u, int v, i64 c) {
    link1(u, v, c), link1(v, u, 0);
}

bool makelevel(int s, int t) {  //广搜标号
    memset(d, 0, sizeof d);
    d[s] = 1;
    int l = 0, r = 0;  //手写队列的指针
    q[r++] = s;
    while (l < r) {
        int u = q[l++];
        if (u == t) {
            return true;  //可达汇点
        }
        for (int i = p[u]; i + 1; i = edge[i].next) {
            int v = edge[i].v;
            if (!d[v] && edge[i].c) {
                q[r++] = v, d[v] = d[u] + 1;
            }
        }
    }
    return false;
}

i64 dfs(int u, i64 flow, int t) {
    if (u == t || !flow) {
        return flow;
    }
    i64 sum = 0;
    for (int& i = cur[u]; i + 1; i = edge[i].next) {
        int v = edge[i].v;
        if (edge[i].c && d[v] == d[u] + 1) {
            i64 tmp = dfs(v, min(1LL * edge[i].c, flow), t);
            edge[i].c -= tmp, edge[i ^ 1].c += tmp;
            flow -= tmp;
            sum += tmp;
            if (!flow) {
                break;
            }
        }
    }

    if (sum == 0) {
        d[u] = -1;  //表示这个点无法放流量了就在此回合屏蔽掉
    }
    return sum;
}
i64 dinic(int s, int t) {
    i64 ans = 0;
    while (makelevel(s, t)) {
        memcpy(cur, p, sizeof cur);
        ans += dfs(s, inf, t);
    }
    return ans;
}

i64 del[N];

int main() {  // ONLINE_JUDGE
    memset(p, -1, sizeof p), eid = 0;
    int n, m;
    cin >> n >> m >> S >> T;
    for (int i = 1; i <= m; i++) {
        int u, v, c1, c2;  //c1<=flow<=c2
        cin >> u >> v >> c1 >> c2;
        del[u] -= c1, del[v] += c1, link2(u, v, c2 - c1);
    }
    for (int i = 1; i <= n; i++) {
        if (del[i] >= 0) {
            link2(SS, i, del[i]);
        } else {
            link2(i, TT, -del[i]);
        }
    }
    dinic(SS, TT);
    link2(T, S, inf);
    int vb = eid - 1;
    dinic(SS, TT);  //保证T->S的反向边是最小流
    for (int i = p[SS]; i + 1; i = edge[i].next) {
        if (edge[i].c) {
            cout << "please go home to sleep\n";
            return 0;  //无解
        }
    }
    int ans = edge[vb].c;  //最小流
    p[S] = edge[p[S]].next, p[T] = edge[p[T]].next;
    ans += dinic(S, T);  //最大流
    cout << ans << "\n";
    return 0;
}

/*
对于原图的边<u,v,L,R>,顶标tpm[u] -= L,tpm[v] += L,连link(u,v,R-L)
对于tpm>0的，连<SS,i,tpm>，否则<i,TT,-tpm>
先跑dinic(SS,TT)。连<T,S,inf>，再跑SS,TT，此时T->S反向边就是最小流
去除T->S的边（将T和S的链前往回指一个指针）。跑S,T，加上这部分流量就是最大流了。
*/

```

## 一些习题

### P2764 最小路径覆盖问题

首先，用最少的路径覆盖所有的点，意味着尽量两条路径能合并就合并。结果为 n-合并的次数。将点拆成入点出点，出点向有边的入点连边（下图出点在左），流量都为 1。

正确性显然：出连入表示两条路径的合并；每个点只能作为某一条路径上的点，（对于出点）一旦从某条边出去，就不能从另外一条边出去。

![img](https://raw.githubusercontent.com/Falicitas/Image-Hosting/main/15945.png)

### P2765 魔术球问题

假设有 n 根柱子，现要按下述规则在这 n 根柱子中依次放入编号为 1，2，3，...的球

1. 每次只能在某根柱子的最上面放球。
2. 同一根柱子中，任何 2 个相邻球的编号之和为完全平方数。

试设计一个算法，计算出在 n 根柱子上最多能放多少个球。例如，在 4 根柱子上最多可放 11 个球。

对于给定的 n，计算在 n 根柱子上最多能放多少个球。

选择拆点。

由于网络流可撤销之前操作，所以动态加新点即可。很显然，需要用尽量少的柱子来装下尽量多的数，那就是最小路径覆盖。

所以按照最小路径覆盖模型来建图，给能挨在一块的数的出点入点连条边，当用的数 - 网络流 > 柱子个数就停止。

### P3163 [CQOI2014]危桥

先让 S 连 a1，b1，T 连 a2，b2 跑看是否满流，再让 S 连 a1，b2，T 连 a2，b1（即交换b1，b2），看是否满流。

假设第一次跑最大流，$a_1\to b_2$​​​​​ 的流量为 x，那么 $b_1\to b_2$​​​​​ 的流量为 $b_n-x$​​​​，$b_1\to a_2$ ​​​的流量也是 x，$a_1\to a_2$​​ 的流量是 $a_n-x$。

而第二次跑最大流，因为是无向图，$a_1\to a_2$​ 和 $b_2\to b_1$​ 的流量可以不变（相当于把 b1，b2 的流量反向），还是 $a_n-x,b_n-x$​。那么 $a_1\to b_2$​ 和 $b_ 2\to a_1$​ 的流量也都还是 x。

既然 $a_1$ 可以在两个图给 $b1,b2$ 流 x 的流量，画个图可知，改变图的流量，可以直接从 b1 流向 b2 额外 x 的流量。

### SP4063 MPIGS - Sell Pigs

M 个猪圈， 1~n 天每天一顾客，每次将自己有钥匙的猪圈打开，并购买一定量的猪（不够则买光）。问最多能买的猪的个数。

把新猪圈里的猪的数量当做边（新猪圈指之前 i-1 天顾客没钥匙的猪圈），从汇点连向第 i 天的顾客，顾客则向 T 连自己的需求量。怎么考虑将之前并在一块的猪圈给之后选这些的顾客提供猪呢？只需将之前并在一块的猪圈对应的顾客 i 向当前的顾客 j 连一条边即可，表示之前合并的猪圈还有剩余猪可以卖给新顾客。

### CF510E Fox And Dinner

小狐狸Ciel参加了一个派对，加上他自己这个派对里总共有 n 只狐狸，每只狐狸有一个年龄 $a_i$。

它们想要在几张圆桌旁吃晚饭，你需要帮忙分配座位，使得满足以下要求：

1. 每只狐狸都在其中
2. 每张桌子边至少有 3 只狐狸
3. 任意两只相邻的狐狸的年龄之和为质数（圆桌上每只狐狸都有2只相邻的狐狸）

看到相加为质数，考虑奇偶划分点集。由于至少3个点围成一桌，那么就证明每个点必有两个 **相邻** 点。每个点要跑2流量才行，即要满流。

### P3097 [USACO13DEC]Optimal Milking G

经典二分跑图。

### P2891 [USACO07OPEN]Dining G

经典三分图。对于中间匹配节点，要拆点保证只流一次。

### P2754 [CTSC1999]家园 / 星际转移问题

多了一维时间，而普通的网络流是不包含时间这一维的（即一瞬间流完）。那么就将除 S，T 外的站点按时间构建分层图。现在有一个飞船，在第 K 天停留在 u，第 K+1 天停留在 v，可以载人 c，则点 (u,K)->(v,K+1) 一条 c 的流量边。由于空间站可以无限时间滞留人，故 (u,T)->(u,T+1) 一条 inf 的流量边。当第 K 天能跑满最大流，那就是第 K 天能送完人。

### P5038 [SCOI2012]奇怪的游戏

多米诺加法过程，故黑白染色。

由于要染到某个数，设这个数为 x。对于每个白点黑点。得 $\sum x - a_{白} = \sum x - a_{黑}$。看看这个式子，如果矩阵的元素为奇（我先染白），则白点个数更多，那就有 $x = \sum a_{白} - \sum a_{黑}$。由于只是能 +，不能 -，所以求出来的 x，要是 $<max(a_白,a_黑)$​ 则非法。那么 x 就确定了。那么跑个网络流，看看是否满流就完事了。

对于矩阵元素个数为偶，那就只能二分（由于必能完整覆盖一层多米诺）。

### P2598 [ZJOI2009]狼和羊的故事

首先知道，狼和羊之间的一条路肯定是至少放一个栅栏的。

故羊连汇点 S inf，羊跟地，羊跟狼连边，地跟地，地跟狼连边，狼跟汇点连边，然后跑个最小割即可。

### P2057 [SHOI2007]善意的投票 / [JLOI2010]冠军调查

左点集为不睡觉，右点集为睡觉。朋友间就连一条边代表发生冲突的代价。然后跑个最小割就好了。

### P3756 [CQOI2017]老C的方块

目前做过的最有意思的网络流题目。

由于处理的方块可以旋转，镜像，处理的情况爆炸，经验丰富的选手就该考虑其共性。

不管旋转，镜像，始终有两个左右方格中间夹着一个蓝线。然后左右方格各自再接一个相邻方块即是要去除的模型。

于是乎，黑白染色，一旦能构成4个方块相连的就非法。即把四个方块穿在一块，然后跑个最小割即可。

![img](https://raw.githubusercontent.com/Falicitas/Image-Hosting/main/A4A59D17D094058842966E7079F5D812.png)

### P2805 [NOI2009] 植物大战僵尸

首先，由于僵尸是从右到左打植物的，那么对于植物来说，默认的有右边植物保护左边植物。

其次，若一个保护关系成了环，那么环上的任意植物都不会被打死。

再者，被环直接或间接保护的植物也不会被打死。

于是只需要把环和被环保护的植物在图上删除掉，其他的植物就一定能顺序被打死。（举两个例子，无敌的植物被不无敌的保护，不无敌的被无敌的植物保护，发现前者无影响反正不选无敌植物，后者会矛盾，无敌植物保护的植物也是无敌的）

忽略删除的点，就变成一个普通图了。这时候就是个裸的最大权闭合子图问题了。

### P3329 [ZJOI2011]最小割 / 【模板】最小割树（Gomory-Hu Tree）

随意挑两个点 u,v，求这两个点的最小割。可以感性发现被割出来的两个点集中任挑两个点，都小于等于 u,v 的最小割。

于是乎，划分成两个集合，只考虑集合里的点对的最小割。

每次求完 u,v 的最小割，就将 u,v 连边。记住，这里的 u,v，是在原图上的最小割，而不是在诱导子图里跑最小割（因为对于任意两点的最小割，等于任意两点全局的最大流）。可以发现，构造出的最小割树，任意两点路径的最小值就是两个点的最小割。由于点不多，直接 bfs 求树上任意一点到其他点的路径最小值。

于是题目就解决了，复杂度 $O(n^3m)$​，但实际很难跑满。

### P3358 最长k可重区间集问题

首先区间只能用一次，故拆点。然后排序，将不相交的区间串起来。最后向每个区间的左点连 S，右点连 T，跑个最大费用最大流即可。

相当于找 k 次増广路，每次找最长的那个。

### P2045 方格取数加强版

建不同费用的题。

每个点拆点，连边时连条容量为1，费用为点权的边，再连一条容量为inf，费用为0的边。跑个费用流就行。

### P1251 餐巾计划问题

一个餐厅在相继的 N 天里,每天需用的餐巾数不尽相同。假设第 i 天需要 r_i 块餐巾（i=1,2,...,N）。餐厅可以购买新的餐巾，每块餐巾的费用为 p 分；或者把旧餐巾送到快洗部，洗一块需 m 天,其费用为 f 分;或者送到慢洗部,洗一块需 n 天（n>m），其费用为 s 分（s<f）。

每天结束时,餐厅必须决定将多少块脏的餐巾送到快洗部,多少块餐巾送到慢洗部,以及多少块保存起来延期送洗。但是每天洗好的餐巾和购买的新餐巾数之和，要满足当天的需求量。

试设计一个算法为餐厅合理地安排好 N 天中餐巾使用计划，使总的花费最小。编程找出一个最佳餐巾使用计划。

关键是如何把行为给描述出来。

对于第i天，必然会产生 $r_i$​ 份脏餐巾，故左点集为脏餐巾。S 向每一天的脏餐巾连一条 $r_i$​ 容量，费用为 0 的边。

对于第i天，必然要用 $r_i$​ 份餐巾。故右点集为干净餐巾。右点集向T连一条 $r_i$​ 容量，费用为 0 的边。

今天用的干净餐巾可以直接买，所以从 S 向右点集连一条单位费用的边。

今天的干净餐巾也可以从 i-m 天的脏餐巾通过洗干净得来，对应的就是洗的费用。

由于每天的脏餐巾可以继承，故 i 向 i+1 的脏餐巾连无费用边。

所有的行为都描述了出来，那么跑个费用流就完事了。

费用流中，用流量很适合来表征限制。本题限制便是一天要产生 r_i 个脏毛巾，以及要使用干净的 r_i 个毛巾。那么节点的设置以及使用的流量就为 r_i。构建好节点后，串联类似于乘法原则，是分步完成事件的抽象描述；并联则是类似于加法原则，是不同步骤完整事件的抽象描述。故干净毛巾既从直接购买而来，同时也可以从 i-m 天的脏毛巾洗干净而来。

### P2053 [SCOI2007]修车

经典后面的人要等前面的人的问题。

经验丰富的选手立刻将问题倒过来。对于一个维修老同志，倒数第 1 个修的车给总时间 + 1 * 修车时间；倒数第 2 个修的车给总时间 + 2 * 修车时间；倒数第 n 个修的车给总时间 + n * 修车时间。

故把老同志拆成车数个点，然后按倒数来顺序建边。跑个费用流，流量为总修车人数就是了。

另外有个优化，由于老同志 * 车数很大！那么可以动态的来加点。每次找到一条増广路，看看是哪个师傅修的，那么此时再往后加一个同个师傅，向每个车连倍数+1的边。

### CF724E Goods transportation

小明升任了 CF 国的大总管，他管辖的 n 个城市，编号为 1..n 。每个城市生产了 p_i 个货物，限制最多可以卖掉 s_i 个货物。对于每两个城市 i, j，如果 i < j，则可以最多从 i 运送 c 个货物到 j。注意不能反向运送，却可以在多个城市之间送来送去。现在小明想知道，经过运输后，最多能卖掉多少个货物。

很明显的网络流建图，但也很明显的 $O(过不了)$。

实质上是求 S 到 T 的最小割。那么每次加一个点，要不将这个点和 S 隔开，要不和 T 隔开。

那就令 $dp(i,j)$ 为选到第 i 个位置，还剩 j 个与 S 相连。

那么 $dp(i,j) = dp(i-1,j) + j * c + p_i$，代表 i 和 S 的所有可能联系都隔开。

$dp(i,j) = dp(i-1,j-1)+s_i$，代表 i 和 T 隔开。取 max 就是答案。

记得有些情况是非法的，初始化要初始化干净。

---以下题解未整理

### P4001 [ICPC-Beijing 2006]狼抓兔子

对偶图模板题。

平面图的网络流 = 对偶图的最短路

首先源点和汇点都在同一个面里，要人为的把它们画成两个区域。

走对偶图的边，实际上就是原图从一个平面到另一个平面（用雨巨的话说就是打破面与面的屏障）

![](C:\Users\Kinesis\Desktop\markdown图片\对偶图1.png)

于是，就可以按照上面的划分方式，建点跑最短路即可。（这种题啊，就是要去标号，以求简洁）

### Place the robots

网格图，有草地，有机器人，有墙。

只要机器人左右前后能看到另一个机器人，就会将其人道毁灭。不能隔着墙看见。问最少放多少个机器人。

这道题啊，就利用了一下网格图的性质了。

一开始若只是把机器人当做点，那就会成为一般图最大独立集问题。是个NP问题。

但按照下面的图的划分方式，则又可以把点当做边了！于是转化成求最大匹配。

<img src="C:\Users\Kinesis\Desktop\markdown图片\place the robots.png" alt="place the robots" style="zoom:67%;" />

### CF316C2 Tidying Up

比较经典的带权网络流题目。

注意啊，是求最少的与原图位置不同的鞋子的数量。所以相邻不同的连一条有费用的边，否则费用为0，跑费用流就是了。

不是最小割啊！自己想想为啥不是。

### CF37E Trial for Chief

[比较有理的题解](https://wenku.baidu.com/view/659cd8c1b14e852458fb5761.html)

### P2604 [ZJOI2010]网络扩容

做一次就会做题目。

费用嘛，那就对于每条原先的边再建多一条边呗。容量为k，单位费用为1的边。

跑费用流就完事了。

### CF362E Petya and Pipes

跟上题一样的建图。

问题是，怎么统计在限定的金钱下，流量的增量呢？

那就从费用流本身下手啊！$d[t]$存的就是单位流量流向t最少花的费用。如果金钱足够，那就直接流满；如果金钱不够了，那就看剩余的金钱够走多少次从s->t。即$\frac{left}{d[t]}$，向下取整。

### P3227 [HNOI2013]切糕

最小割！

经验丰富的选手啊，一眼一看！一个位置的高度只能选一种啊！

于是，先不管位置间的限制，那就是每个位置要割一条代表的边啊！

然后去考虑限制。

一个位置选了某一个数u，那么对于另一个数，是不是必须要割u-D以后的数v哇？（你割了前面，那后面的点由于u那可以提供流量，所以就割不断啊）

于是就建好边，跑个最小割就是了。

### CF720B Cactusophobia

不是环上的边，怎么可以删！

环上的边，是不是只用删一条！

最大流！

建点做限制就完事！记住是每种颜色存在仅算一次！

### CF884F Anti-Palindromize

经验丰富的选手啊，一看这个位置为a的，最后要是也放了a，是不是可以理解成没动啊？

那就按字符把字符全拿出来。

对于一个位置，还放原先字符的，那就有贡献。

还有一个问题，对称位置不能放同一种字符。那么限制拆成26种字符，每种字符仅流出1的流量就是了！

### CF863F Almost Permutation

有点像修车！

但是，对于来什么位置，贡献都是一样！所以只用一个点就完事！

### 混合图欧拉回路

混合图的欧拉回路，无向边只走一次的啊。

首先啊，随机定向边。

如果边的入度和出度之差为奇数，那么不管怎么换边方向也是奇数，必挂。

否则，就再跑网络流看看是否有解。

具体的，将原来的有向边删掉！然后呢，在原来的已定向边，建图。S向入度小于出度的点连边，T向入度大于出度的点连边。能满流就存在欧拉回路。

