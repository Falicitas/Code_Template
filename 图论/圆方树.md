# 圆方树

圆方树是将一般图转化为一颗树进而更加简便的处理信息的一类算法。

大致的构建方式如下代码：

```cpp
void tarjan(int u,Link &l2)
    {
        dfn[u] = low[u] = ++cnt;
        sta[++top] = u;
        UREP(i,u){
            int v = edge[i].v;
            if(!dfn[v]){
                tarjan(v,l2);
                low[u] = min(low[v],low[u]);
                if(low[v]>=dfn[u]){
                    poi++;//方点标号
                    l2.link2(poi,u);
                    int cur;
                    do{
                        cur = sta[top--];
                        l2.link2(poi,cur);
                    }while(cur!=v);
                }
            }
            else low[u] = min(low[u],dfn[v]);
        }
    }
```

<img src="C:\Users\Kinesis\Desktop\markdown图片\圆方树1.png" style="zoom:50%;" />

可以发现，每个点双上的圆点与方点构成了菊花图。

## 性质

可以发现，非叶子的原点均为割点。

而两个原点的「唯一路径」，则是原图两个点的**所有简单路径的并** 。

通常会在圆方树上的圆点or方点设置恰当的点权，以达到信息的便捷统计。

## 一些习题

### P4630 [APIO2018] Duathlon 铁人两项

仔细观察题目要求的关系 $<u,c,v>$。

首先必然要固定 $u,v$​。考虑这个 c，不就是 $u,v$​ ​的所有简单路径的点集的并减去 u,v 嘛？

如何统计两个路径的点集的并？对于圆点，点权设为 -1，方点则是点双的大小。画图能得知其就为两圆点上的路径和。

怎么推出点权的设置？很明显，对于一个点双上的两点，剩下的任意节点都可以作为中转站c，所以才将方点设为点双大小；又如起点终点不算到答案里，割点会被两个点双计算多一次，所以均设为 -1。

两点间的关系跟有根无根无关，先转为有根树。其次任意两点的路径和也不好统计，转为每一个原点会被多少路径覆盖，树形dp就统计出来了。（不会树形dp的还是看一看吧。。）

### P4606 [SDOI2018]战略游戏

题意是，图上给标 S 个点，去掉一个未标记的点能使其中一对标记点对不连通，问这样的点的集合是什么。

套路上一个圆方树。由于是点对关系，转成有根树。

对于能断掉其中一些点对的点，观察可知均为路径上的割点。然后手画几个树，把会被统计到答案的点全部画出来。这就是包含了所有 S 个点的**最小连通块**啊！

怎么求包含树上所有关键点的**最小连通块**呢？将 S 个点按照 dfn 序排好，每次对相邻两个点进行路径覆盖。基本的最小连通块的点都被覆盖了两次（还差点 S 和点 1 的被覆盖一次，那就 S 到 1 再覆盖多一次）。有一些细节要处理，比如 lca 不覆盖，以及 S 和 1 的 lca 未被覆盖。

关于最小连通块，有个相关题目「寻宝游戏」。

### CF487E Tourists

由于求得是两个点路径并的最小值，所以考虑构建圆方树，其中方点维护周围圆点的最小值。

但修改时不需要把所有的方点都修改，仅需修改父节点。

可以发现，当路径查询的 lca 是方点时，只要把该方点的父节点（必然是原点）加入到答案中来即可。