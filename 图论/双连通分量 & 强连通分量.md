# 双连通分量 & 强连通分量

## 求割点 / 求点双连通分量

对于一个搜索树来说，若一个点 u 对于其子树 v 来说，满足 $low[v]\geq dfn[u] $ ​时，此时**栈顶的元素至v节点与u可构成一个点双连通分量**。而对于搜索树的根节点来说，其不仅要满足上述条件，同时要存在至少2颗子树才能成为割点。**而单纯求某一点属于的点双连通分量时，则不需要管是否为搜索树根节点。**

对于点双缩点后的一棵树，可以记录一些信息来判断缩点后的性质：siz[],deg[]。（当然这里的 siz 不一定就是点双缩点后里面的点的个数，故 siz 是在 tarjan 里求得的）

- 对于 siz[u]==1 的点来说，其既有可能是单独的一个非割点，也有可能是割点。单独的非割点的 deg[u]=1，而割点则是 deg[u]>1。
- 对于 siz[u]==2 的点来说，其是一个点对。
- 对于 siz[u]>=3 的点来说，其是一个复杂环。对于仙人掌图，缩点后的 siz[u]>=3 时，其是一个单纯环。

注：当一个点双连通分量的秩大于等于 3 时，其必为一个环。等于 2 时，其为一个点对。

虽然 tarjan 点双缩点缩得很难看，不过硬是要分，那对于缩点后的树，要不是一个点双的**主要部分**，要不是割点。

常用代码：

```cpp
void tarjan(int u)
{
    dfn[u] = low[u] = ++cnt;
    sta[++top] = u;
    UREP(i,u){
        int v = edge[i].v;
        if(!dfn[v]){
            tarjan(v);
            low[u] = min(low[u],low[v]);
            if(dfn[u]<=low[v]){
                int tot = 1;//表示点双连通分量的大小
                _REP(i,top,1){
                    tot++;
                    if(sta[i]==v) break;
                }
                if(tot==...){
                 	//对特定大小的点双连通分量进行处理   
                }
                top -= tot - 1;//保留割点、搜索根节点
            }
        }
        else low[u] = min(low[u],dfn[v]);
    }
}
```

## 求割边 / 边双连通分量

不管是求割边还是求边双连通分量都比较简单。边双连通分量只需要标记完割边后dfs一次即可。

常用代码：

```cpp
void tarjan(int u,int fa)
{
    dfn[u] = low[u] = ++cnt;
    UREP(i,u){
        int v = edge[i].v;
        if(v==fa) continue;
        if(!dfn[v]){
            tarjan(v,u);
            low[u] =  min(low[u],low[v]);
            if(dfn[u]<low[v]){
                cut_line[i] = 1;//标记割边
            }
        }
        else low[u] = min(low[u],dfn[v]);
    }
    if(low[u])
}
```

## 求强连通分量

也是比较简单。对于有向图来说，会出现横插边的情况，处理一下当前的v是否还在栈里即可。

tarjan 不能解决自环。本质是缩

常用代码：

```cpp
function<void(int)> tarjan = [&](int u) {
    dfn[u] = low[u] = ++cnt;
    sta[++top] = u, vis[u] = 1;
    for (auto v : e[u]) {
        if (!dfn[v]) {
            tarjan(v);
            low[u] = min(low[u], low[v]);
        } else if (vis[v])
            low[u] = min(low[u], dfn[v]);  //忽略横插边的影响
    }
    if (dfn[u] == low[u]) {
        cc++;
        int cur;
        do {
            cur = sta[top--], vis[cur] = 0;
            num[cur] = cc;
        } while (u != cur);
    }
};
```

### P2341 [USACO03FALL] [HAOI2006] 受欢迎的牛 G

水题。缩点后处理一下。

### P2272 [ZJOI2007]最大半连通子图

虽说是半联通啊，要求没那么严格啊，但原本可以作为强连通的那就先搞一搞啊。

缩完点后，发现只能是一条路径上的节点能够“相互到达”。这时跑个 dp 就完事了。

### Network of Schools

给你一张有向图, 问最少要加几条边才能使得图上的点都属于同一个强连通分量。

缩点后，直接 $max(cnt_{in = 0},cnt_{out = 0})$​。

对于每个出点为 0 的点，从左到右向入点为 0 的点连边，可以发现原来是入点为 0 的点能到出点为 0 的点，现在（之前）出点为 0 的点能到入点为 0 的点。同时原本入点为 0 的点能到其他的出点为 0 的点。最后可以形成若干个环。

### P3225 [HNOI2012]矿场搭建

有点意思的贪心题目。

考虑到一个点坍塌了（即割掉一个点）后，点双连通分量的其他点还连通，故考虑点双缩点。

缩完点后，若当前点双连通（主要部分）的 deg>=2，说明不管炸掉哪个割点都能跑到其他点双连通块里，故不需要建；deg=1 的建一个，deg=0 的建两个。

### SP2878 KNIGHTS - Knights of the Round Table

对于一个点双连通，若存在一个奇环，那么点双连通里的任意一个节点都能在至少一个奇环集中。

就相当于一个点分别找两条路径（必定能找到- -）连向那个奇环，奇环必然是由一个奇弧和一个偶弧构成。于是必能构造一个奇数的环。那判点双里有无奇环，只需要 tarjan 中把点双的点标记出来，黑白染色点双里的点就是了。

### UVA610 Street Directions

给一个连通无向图定尽量多的边的方向，使其为一个强连通。

很有意思的题目。考虑 tarjan 的过程，对于返祖边能连向的上面的搜索点，跟下面的构成一个圈圈，此时圈圈上的点只要按照搜索的过程来定边，仍能相互到达。唯一要保留双向边的就只有割边。tarjan 一次就能输出完答案。

### King's Quest

给一个存在完美匹配的二分图，问每个左点集的点能在保证完美匹配的前提下匹配到哪些右点集的点。

首先对于完美匹配的边，右点集连左点集（有向边），对于原图，左点集连右点集。对于构成了强连通的点都可以到达，即强连通里的右点集都可以选。

画个图就知道了。。

### P1477 [NOI2008] 假面舞会

这道题啊，这道题的实现方式很有意思。

对于题目的最大最小，做出图来就很明显了。

那么怎么求各类环长度的 gcd？

给原图每条边加一条反向边，权值为 -1。这使就使任意弱连通图保证联通。

对于环啊，你顺着走，反着走，统计的长度都是一样的。所以啊，就 O(N+M) 搞出来了啊。

```cpp
void dfs(int u,int d)
{
    if(dis[u]){
        ans = __gcd(ans,abs(d - dis[u]));
        return ;
    }
    dis[u] = d,vis[u] = 1;
    mn = min(mn,dis[u]);
    mx = max(mx,dis[u]);
    UREP(i,u) dfs(edge[i].v,d+edge[i].w);
}
```

### C Cover the Tree 2020牛客多校训练营第二场

选最少的路径条数，使树上每条边至少被覆盖一次。

画个图，发现贪心选两个节点均为叶节点的路径最好。这就有点像添多少条边使树没有割边那道题一样，个数为 $\frac{n+1}{2}$​ 。

找一个重心，这里的重心指的是所有子树的叶节点（指 deg=1）个数最多的最少。以这个重心为根的树有这样的性质：子树叶节点个数最多的最多不超过 n/2，否则可以通过移动重心来使满足这个条件。那么每次从重心的含最多叶节点的两个子树中取两个点，将其连边。最后若剩一个点直接跟根节点连。可以用 set+queue 维护。

### CF901C Bipartite Segments

无向图，无偶环。首先推出的信息是，图要不是无环图，要不是带奇环的图。

还能继续推。这个图必然是仙人掌图。考虑两个奇环有公共边，那么就必能找到一个偶环。反推回其为仙人掌图。

那么可以轻易用 tarjan 把所有环找出来。

对于一个环，最小标号和最大标号确定了奇环在数轴上的范围。对于任意选出来的合法区间，必不能 **包含** 一个奇环代表的连续区间。那么经验丰富的选手就考虑求当前点能往右延展至最长的合法区间 nxt。对于这个啊，考虑加入一个非法区间，数轴上nxt的变化就知道如何求了。

很明显，nxt 是单调不减的。于是对于一个区间，直接二分找到 nxt大于等于 r 的位置，该位置此后的右区间直接限定在r。对于剩余的左边位置，直接求个前缀和即可（右区间不受限制）。
