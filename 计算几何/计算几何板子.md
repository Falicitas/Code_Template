# 计算几何板子

### 点、向量、线（简称几何头文件）

- **点** ：用一个pair存。 **向量** ：用一个pair存。 **直线** ：用一个 *代表点* 和一个 *方向向量* 表示一个直线（由于直线的极角为 $[0,\pi)$ ，故 *方向向量* 仅处在第一，第二象限）。 **线段** ：一般不在极坐标系下存线段，在直角坐标系下存两个点。 **多边形** ：按顺序存顶点。特殊的，对于边平行坐标轴的矩形，可仅存左下角和右上角的顶点。 **曲线** ：一般记录解析式。对于圆，记录圆心和半径。

- 计算几何的 **精度误差eps** 一半设为 $[1e-10,1e-7]$ 的区间。由此判定点，边等各类重合情况。

- **叉积** ： $a \times b$ ，大小为 $|a||b|\sin\theta = \det|将向量展开后的矩阵| = x_1y_2 - x_2y_1(二维平面向量)$ 。是矢量，遵循右手定则。

- **点积** ：$a\cdot b$ ，大小为 $|a||b|\cos\theta = x_1y_1 + x_2y_2(二维平面向量)$ 。是标量。 

- **正弦定理** ： 角A对着的边为a， $\frac{a}{\sin A} = \frac{b}{\sin B} = \frac{c}{\sin C} = 2R$ ，R为外接圆半径。 **余弦定理** ： $a^2 = b^2 + c^2 -2bc\cos A$ ，其余2个边同理。

- **规范函数名**

- > **符号函数、比较函数** ：
  >
  > db ： double
  >
  > `int sign(db a) { return a < -eps ? -1 : a > eps; }
  > int cmp(db a, db b){ return sign(a-b); }
  > `
  >
  > `#define SZ(x) ((int)(x).size())`

- **点、向量** ： 结构体 $P$ 

  > 个人推荐写成员函数
  >
  > **点积** ： `db dot(P p) { return x * p.x + y * p.y; }`
  >
  > **叉积** ： `db det(P p) { return x * p.y - y * p.x; }`
  >
  > **点减（构造两点向量）、点加** ： `P operator+(P p) { return {x + p.x, y + p.y}; } P operator-(P p) { return {x - p.x, y - p.y}; } `
  >
  > **向量乘除 $\lambda$ ** ： `P operator*(db d) { return {x * d, y * d}; } P operator/(db d) { return {x / d, y / d}; }`
  >
  > **向量模** ： `db abs() { return sqrt(abs2());} db abs2() { return x * x + y * y; }`
  >
  > **两点距离（等同两点向量模）** ： `db distTo(P p) { return (*this - p).abs(); }`
  >
  > **顺时旋转 $\pi / 2$ ** ： `P rot90() { return P(-y,x);}`
  >
  > **转单位向量** ： `P unit() { return *this/abs(); }` 
  >
  > **向量角度判定（ $[0,\pi)$ ）** ： `int quad() const { return sign(y) == 1 || (sign(y) == 0 && sign(x) >= 0); }`
  >
  > **顺势旋转an度** ： 
  >
  > $(\cos Ar,\sin Ar) \rightarrow (\cos(A+B)r,\sin(A+B)r) =((\cos A \cos B-\sin A \sin B) r,(\sin A \cos B+\cos A \sin B) r)$ ，将含 $\sin Ar,\cos Ar$ 代换成 $y,x$ ，得到 $(x \cos B-y \sin B, x \sin B+y \cos B)$ 
  >
  > `P rot(db an){ return {x*cos(an)-y*sin(an),x*sin(an) + y*cos(an)}; }`

- **线** ：结构体 L

  > **存两个点** ： `P ps[2]`（p0 -> p1）
  >
  > **直接访问两个点** ：`P& operator[](int i) { return ps[i]; }`
  >
  > **获得向量** ：`P dir() { return ps[1] - ps[0]; }`
  >
  > **构造函数** ：`L (P a,P b) {
  > 		ps[0]=a;
  > 		ps[1]=b;
  > 	}`
  > **判断点是否在直线对应的半平面交内（默认在向量左侧）** ：`bool include(P p) { return sign((ps[1] - ps[0]).det(p - ps[0])) > 0; }`
  > **修正精度（暂不知道如何用）** ：`L push(){ // push eps outward
  > 		const double eps = 1e-8;
  > 		P delta = (ps[1] - ps[0]).rot90().unit() * eps;
  > 		return {ps[0] + delta, ps[1] + delta};
  > 	}`

### 点、直线、线段位置关系（简记为Intersect部分）

- **直线的方向向量** ：养成好习惯，让y坐标大的做箭头顶，向量的y轴投影指向y的非负半轴。

- **点与直线的位置关系** ： 记直线的元素为 $<P,\mathbf{v}>$ ，点为 $Q$ 。若 $\overrightarrow{PQ} \times \mathbf{v} < 0$ ，则Q在直线上方（记住方向向量始终在第一第二象限）；= 0则在直线上；< 0则在直线下方。 

<img src="https://raw.githubusercontent.com/Falicitas/Image-Hosting/main/%E5%8F%B3%E6%89%8B%E5%AE%9A%E5%88%99.png" style="zoom:67%;" />

- **判断点是否在线段上** ： 

  >第一步，先判断叉积是否为0。为0时点与线段共线。
  >
  >再判断点是否在线段对应的矩形中，类似于快速排斥实验。
  >
  >```cpp
  >bool isMiddle(db a, db m, db b) {
  >	return sign(a - m) == 0 || sign(b - m) == 0 || (a < m != b < m);
  >}
  >
  >bool isMiddle(P a, P m, P b) {
  >	return isMiddle(a.x, m.x, b.x) && isMiddle(a.y, m.y, b.y);
  >}
  >
  >bool onSeg(P p1, P p2, P q){
  >	return crossOp(p1,p2,q) == 0 && isMiddle(p1, q, p2);
  >}
  >
  >bool onSeg_strict(P p1, P p2, P q){
  >	return crossOp(p1,p2,q) == 0 && sign((q-p1).dot(p1-p2)) * sign((q-p2).dot(p1-p2)) < 0;
  >}
  >```

- **判断两线段关系** ：

  > **快速排斥实验** ：
  >
  > 相当于两个线段分别对应两个矩形。 **未通过快速排斥实验** 则是存在x维度或y维度，使得两个线段在对应维度的 **投射** 没有交集。反之则 通过快速排斥实验 。**未通过快速排斥实验** 是线段 **不相交** 充分不必要条件。
  >
  > ```c++
  > bool intersect(db l1,db r1,db l2,db r2){
  > 	if(l1>r1) swap(l1,r1); if(l2>r2) swap(l2,r2); 
  > 	return !( cmp(r1,l2) == -1 || cmp(r2,l1) == -1 );
  > }
  > 
  > intersect(p1.x,p2.x,q1.x,q2.x) && intersect(p1.y,p2.y,q1.y,q2.y) //为1则通过快速排斥实验
  > ```
  >
  > **跨立实验** ：
  >
  > 做两组实验 ： 对于线段 L1 ，是否 L2 的两点处在L1代表直线的两端（即叉积乘为负） ；对于线段 L2 ，是否 L1 的两点处在L2代表直线的两端（即叉积乘为负）
  >
  > **非严格的线段判交** ： *非严格* 指的是一条线段的 **端点** 可以在另一条线段上。需要同时使用两个实验进行判定（对于线段共线的情况，跨立实验会通过二不一定相交）
  >
  > **严格的线段判交** ： *严格* 即两线段仅交于非端点处或不交。
  >
  > 代码：
  >
  > ```cpp
  > #define cross(p1,p2,p3) ((p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y))//三点构建两向量，做叉积
  > #define crossOp(p1,p2,p3) sign(cross(p1,p2,p3))//符号
  > 
  > bool isSS(P p1, P p2, P q1, P q2){
  > 	return intersect(p1.x,p2.x,q1.x,q2.x) && intersect(p1.y,p2.y,q1.y,q2.y) &&
  > 	crossOp(p1,p2,q1) * crossOp(p1,p2,q2) <= 0 && crossOp(q1,q2,p1)
  > 			* crossOp(q1,q2,p2) <= 0;
  > }
  > 
  > bool isSS_strict(P p1, P p2, P q1, P q2){
  > 	return crossOp(p1,p2,q1) * crossOp(p1,p2,q2) < 0 && crossOp(q1,q2,p1)
  > 			* crossOp(q1,q2,p2) < 0;
  > }
  > ```

- **求投影点** ：

  > 求(p1,p)在(p1,p2)上的投影，等于从p1点往(p1,p2)的方向位移 $|(p1,p)\cos\theta|$ 的距离。
  >
  > ```cpp
  > P proj(P p1, P p2, P q) {
  > 	P dir = p2 - p1;
  > 	return p1 + dir * (dir.dot(q - p1) / dir.abs2());
  > }
  > ```

- **求一点相对直线的镜像点** ：

  >求出投影点后，投影点则作为镜像点的 *中点* ，根据中点公式求出镜像点。
  >
  >```cpp
  >P reflect(P p1, P p2, P q){
  >	return proj(p1,p2,q) * 2 - q;
  >}
  >```

- **求点、线段到线段的最短距离** ：

  > 点到线段最短距离：若点在线段的投影在线段上，则最短距离是投影点到点的距离（垂直），否则是线段两个端点到点的最短距离。
  >
  > 线段到线段的最短距离：多画图，可以发现仅有线段的端点可能成为到另一条线段最短的 点 ，那么分别求端点的答案。
  >
  > ```cpp
  > db nearest(P p1,P p2,P q){
  > 	P h = proj(p1,p2,q);
  > 	if(isMiddle(p1,h,p2))
  > 		return q.distTo(h);
  > 	return min(p1.distTo(q),p2.distTo(q));
  > }
  > 
  > db disSS(P p1, P p2, P q1, P q2){
  > 	if(isSS(p1,p2,q1,q2)) return 0;
  > 	return min(min(nearest(p1,p2,q1),nearest(p1,p2,q2)), min(nearest(q1,q2,p1),nearest(q1,q2,p2)));
  > }
  > ```

- **求两个直线的交点** ：

  > 利用了一些 **相似图形** （相似图形，对应边成比例）的原理。建议手动画图，然后记住。
  >
  > 一维数轴上， $b > a$ ，现已知 $[a,b]$ 中有一点 c ，且 $[a,c]:[c,d] = e:f$ ，则$c = \frac{a*f+b*e}{e+f}$ 。（画图可证）
  >
  > ```cpp
  > bool chkLL(P p1, P p2, P q1, P q2) {//判断两个直线是否平行
  > 	db a1 = cross(q1, q2, p1), a2 = -cross(q1, q2, p2);
  > 	return sign(a1+a2) != 0;//平行时，自己画这个向量的叉积，都是相同的
  > }
  > 
  > P isLL(P p1, P p2, P q1, P q2) {//考虑a1,b1的实际含义（平行四边形的面积），则相同底边，面积比等于长度比。
  > 	db a1 = cross(q1, q2, p1), a2 = -cross(q1, q2, p2);
  > 	return (p1 * a2 + p2 * a1) / (a1 + a2);
  > }
  > 
  > P isLL(L l1,L l2){ return isLL(l1[0],l1[1],l2[0],l2[1]); }
  > ```

- **极角排序** ：

  > 选取点集中y值最小的点（y值相同则x值最小）作为排序点，此时所有的向量都在y非负半轴上。
  >
  > $\operatorname{atan2}$
  >
  > 通过Rt三角形的 *对边* 和 *邻边* 来计算角大小的函数。参数 `atan2(a.y,a.x)` 。比如 `atan2(1,1) = 0.78,atan2(1,0) = 1.57`。
  >
  > **叉积**
  >
  > 向量 $\overrightarrow{OP_1} \times \overrightarrow{OP_2}$ 大于0，则 P_1 的极角小于 P_2 ，反之则 P_1 的极角大于等于 P_2 。

- **两直线夹角** ：

  > 求出夹角对应的对边 $a \times b$ ，邻边 $a \cdot b$ ，则调用atan2即可。
  >
  > ```cpp
  > db rad(P p1,P p2){
  > 	return atan2l(p1.det(p2),p1.dot(p2));
  > }
  > ```

### 计算几何（Polygon）

- **Jordan curve theorem** ： 在欧式平面，一个闭曲线 J 将平面划分成两个部分。相同部分里的点对可以画一个弧且弧与 J 相交 *偶数次* （可以不相交）。而不同部分的点画弧必与 J 相交 *奇数次*  。

- **判断点在多边形内还是外** ：

  > 由上面的定理，选择一个点做射线。一般选择与x轴平行指向负无穷的射线。若统计到的为奇数，在多边形内，否则在多边形外。
  >
  > ```cpp
  > int contain(vector<P> ps, P p){ //2:inside,1:on_seg,0:outside
  > 	int n = ps.size(), ret = 0;
  > 	rep(i,0,n){
  > 		P u=ps[i],v=ps[(i+1)%n];
  > 		if(onSeg(u,v,p)) return 1;
  > 		if(cmp(u.y,v.y)<=0) swap(u,v);
  > 		if(cmp(p.y,u.y) >0 || cmp(p.y,v.y) <= 0) continue;//仅考虑会相交的边
  > 		ret ^= crossOp(p,u,v) > 0;//保证u在上后，可以发现（当点在多边形内）只有左侧的边会统计到
  > 	}
  > 	return ret*2;
  > }
  > ```

- **求任意多边形周长和面积**

  > **周长**
  >
  > 直接线扫边计算
  >
  > **面积**
  >
  > 考虑叉积模的实际含义。将多边形按顺序标为 $p_0,p_1,\dots$ ，任选一个辅助点 $O$ （可以试着画在多边形外侧），令 $v_i = p_i - O$ ，则 $S = |\sum\limits_{i=0}^{n-1}\frac{1}{2}v_i\times v_{i+1 \bmod n} |$
  >
  > ```cpp
  > db area(vector<P> ps){
  > 	db ret = 0; rep(i,0,ps.size()) ret += ps[i].det(ps[(i+1)%ps.size()]);
  > 	return ret/2;
  > }
  > ```

- **求凸包** ：

  > 能把所有点包含进去的，面积最小的闭曲线。
  >
  > 把点按x为第一关键字，y为第二关键字，排序。可以发现凸包上的点的向量按逆时针旋转。
  >
  > 那么从0到n-1遍历，维护下凸壳是比较容易的。具体的，将点扔入栈内，使用叉积判断三个点的位置关系以维护一个凸壳。
  >
  > 再倒序遍历一次，维护上凸壳。由于最左的点在凸包里（是正确的，感性证明就行），最右的点参与叉积判断，所以上下凸壳能围成封闭图形。
  >
  > 非严格的凸包，点可以在凸包边上。弹栈的条件降低。
  >
  > ```cpp
  > vector<P> convexHull(vector<P> ps) {
  > 	int n = ps.size(); if(n <= 1) return ps;
  > 	sort(ps.begin(), ps.end());
  > 	vector<P> qs(n * 2); int k = 0;
  > 	for (int i = 0; i < n; qs[k++] = ps[i++])
  > 		while (k > 1 && crossOp(qs[k - 2], qs[k - 1], ps[i]) <= 0) --k;
  > 	for (int i = n - 2, t = k; i >= 0; qs[k++] = ps[i--])
  > 		while (k > t && crossOp(qs[k - 2], qs[k - 1], ps[i]) <= 0) --k;
  > 	qs.resize(k - 1);
  > 	return qs;
  > }
  > 
  > vector<P> convexHullNonStrict(vector<P> ps) {
  > 	//caution: need to unique the Ps first
  > 	int n = ps.size(); if(n <= 1) return ps;
  > 	sort(ps.begin(), ps.end());
  > 	vector<P> qs(n * 2); int k = 0;
  > 	for (int i = 0; i < n; qs[k++] = ps[i++])
  > 		while (k > 1 && crossOp(qs[k - 2], qs[k - 1], ps[i]) < 0) --k;
  > 	for (int i = n - 2, t = k; i >= 0; qs[k++] = ps[i--])
  > 		while (k > t && crossOp(qs[k - 2], qs[k - 1], ps[i]) < 0) --k;
  > 	qs.resize(k - 1);
  > 	return qs;
  > }
  > ```

- **判点是否在凸多边形内 $O(\log n)$ ** ：

  > 首先判断点与凸多边形的极角关系。若点不在射线 $(p_0,p_1)->(p_0,p_{n-1})$ ，则必不在凸多边形内。
  >
  > 否则在这个射线框出来的区间内进行极角二分，找到对应区间内，再叉积一次判断在凸多边形内还是凸边形外。
  >
  > ```cpp
  > bool in(vector<P>& ps,P p0)//Onseg included
  > {
  >  if(crossOp(ps[0],ps[1],p0)<0||crossOp(p[0],p[SZ(ps)-1],p0>0)) return 0;
  >  int id = lower_bound(ps.begin(),ps.end(),p0,cmp2) - ps;
  >  return crossOp(ps[id],ps[(id+1)%SZ(ps)],p0) >= 0;
  > }
  > 
  > ```

- 求半平面交：

  > **半平面交** ：对于一条直线 $Ax+By+C\geq 0$ ，即为该直线对应的半平面。默认向量的 *左侧* 为该向量对应的半平面。那么半平面交就是所有向量对应的半平面的 *交* ，类似于线性规划。
  >
  > 半平面交若存在，一定为凸多边形（画图易证）。于是按极角给线对应的向量排序。
  >
  > 由于半平面靠左，对于同方向的向量，优先让左边的向量靠前，另外的可以直接舍弃（不影响答案）。
  >
  > 先判断队尾的两向量交点，交点在当前向量右侧则弹队尾；再判断队首。正确性oiwiki上有说明。
  >
  > 最后让队首的元素检测队尾。
  >
  > ```cpp
  > bool parallel(L l0, L l1) { return sign( l0.dir().det( l1.dir() ) ) == 0; }
  > 
  > bool sameDir(L l0, L l1) { return parallel(l0, l1) && sign(l0.dir().dot(l1.dir()) ) == 1; }
  > 
  > bool cmp (P a,  P b) {
  > 	if (a.quad() != b.quad()) {
  > 		return a.quad() < b.quad();
  > 	} else {
  > 		return sign( a.det(b) ) > 0;
  > 	}
  > }
  > 
  > bool operator < (L l0, L l1) {
  > 	if (sameDir(l0, l1)) {
  > 		return l1.include(l0[0]);
  > 	} else {
  > 		return cmp( l0.dir(), l1.dir() );
  > 	}
  > }
  > 
  > bool check(L u, L v, L w) {
  > 	return w.include(isLL(u,v));
  > }
  > 
  > vector<P> halfPlaneIS(vector<L> &l) {
  > 	sort(l.begin(), l.end());
  > 	deque<L> q;
  > 	for (int i = 0; i < (int)l.size(); ++i) {
  > 		if (i && sameDir(l[i], l[i - 1])) continue;
  > 		while (q.size() > 1 && !check(q[q.size() - 2], q[q.size() - 1], l[i])) q.pop_back();
  > 		while (q.size() > 1 && !check(q[1], q[0], l[i])) q.pop_front();
  > 		q.push_back(l[i]);
  > 	}
  > 	while (q.size() > 2 && !check(q[q.size() - 2], q[q.size() - 1], q[0])) q.pop_back();
  > 	while (q.size() > 2 && !check(q[1], q[0], q[q.size() - 1])) q.pop_front();
  > 	vector<P> ret;
  > 	for (int i = 0; i < (int)q.size(); ++i) ret.push_back(isLL(q[i], q[(i + 1) % q.size()]));
  > 	return ret;
  > }
  > ```
  >
  > 

- 内心、外心、垂心 ：

  >```cpp
  >P inCenter(P A, P B, P C) {//内心
  >	double a = (B - C).abs(), b = (C - A).abs(), c = (A - B).abs();
  >	return (A * a + B * b + C * c) / (a + b + c);
  >}
  >
  >P circumCenter(P a, P b, P c) {//外心
  >	P bb = b - a, cc = c - a;
  >	double db = bb.abs2(), dc = cc.abs2(), d = 2 * bb.det(cc);
  >	return a - P(bb.y * dc - cc.y * db, cc.x * db - bb.x * dc) / d;
  >}
  >
  >P orthocenter(P a, P b, P c) {//垂心
  >	P ba = b - a, ca = c - a, bc = b - c;
  >	double Y = ba.y * ca.y * bc.y,
  >	A = ca.x * ba.y - ba.x * ca.y,
  >	x0 = (Y + ca.x * ba.y * b.x - ba.x * ca.y * c.x) / A,
  >	y0 = -ba.x * (x0 - c.x) / ba.y + ca.y;
  >	return {x0, y0};
  >}
  >
  >```
  >
  >

- **两凸包闵科夫斯基和 $O(n+m)$ ** ：

  > **闵科夫斯基和** ：定义为图形A，图形B，闵可夫斯基和得到的图形C满足，$C = \{c|(a+b),a\in A,b\in B\}$ 。
  >
  > 两凸包的闵可夫斯基和的边 *恰为* 两图形的边之和。故使用双指针（凸包的边已按照极角排好序），来 $O(n+m)$ 求闵科夫斯基和。
  >
  > 凸壳也可视作满足性质的凸包（将首尾点相连），比如可以 $O(n+m)$ 合并两下凸壳。
  >
  > ```cpp
  > void Minkowski()
  > {
  > 	for(ll i=1;i<n;i++) s1[i]=C1[i+1]-C1[i];s1[n]=C1[1]-C1[n];
  > 	for(ll i=1;i<m;i++) s2[i]=C2[i+1]-C2[i];s2[m]=C2[1]-C2[m];
  > 	A[tot=1]=C1[1]+C2[1];
  > 	ll p1=1,p2=1;
  > 	while(p1<=n&&p2<=m) ++tot,A[tot]=A[tot-1]+(s1[p1]*s2[p2]>=0?s1[p1++]:s2[p2++]);
  > 	while(p1<=n) ++tot,A[tot]=A[tot-1]+s1[p1++];
  > 	while(p2<=m) ++tot,A[tot]=A[tot-1]+s2[p2++];
  > }
  > ```
  >
  > 

