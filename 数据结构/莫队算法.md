# 莫队算法

利用 **双指针** 和 **巧妙的查询排序** 的离线算法。

假设对区间 $[l,r]$ 的信息已获取完毕，如果区间 $[l,r+1],[l,r-1],[l-1,r],[l+1,r]$ 的基于 $[l,r]$ 的信息获取复杂度是 **平凡** 的 $O(1)$（不宜过高，不然复杂度爆炸），这时对查询的区间 $[ql,qr]$ 中按 $ql$ **块编号** 为第一关键字，按 $qr$ **下标编号** 为第二关键字进行排序，将双指针顺序移到查询的区间以计算答案，可以达到复杂度为 $O(\frac{n^2}{S}+mS)$，$n$ 为序列长度，$S$ 为块长，$m$​​ 为查询次数。

代码的形式：

```cpp
void add(int x)
{
    cnt[x]++;
    if(cnt[x]==1)ans++;
}

void del(int x)
{
    cnt[x]--;
    if(cnt[x]==0)ans--;
}

//在获取答案时：init l = r = 0
while(l>q[i].l) add(a[--l]);
while(r<q[i].r) add(a[++r]);
while(l<q[i].l) del(a[l++]);
while(r>q[i].r) del(a[r--]);
```

## 复杂度分析

对于查询左区间 $ql$​ ​在同一块，由于右区间 $qr$​ ​是连续向右的，复杂度为 $O(n)$​​。块的个数为 $\frac{n}{S}$​​，故块间查询复杂度为 $O(\frac{n^2}{S})$​​。由于块内的 $ql$ ​​可能在块间反复横跳，故真复杂度为 $O(\frac{n^2}{S} + mS)$​​。故设计块长需要根据这类复杂度来计算。比如上面的复杂度，设计块长 $S = \frac{n}{\sqrt{m}}$ 理论上比较优​​。

一类卡常的技巧按奇偶性排序：

```cpp
//另一版本
bool operator<(const node&rhs) const
{
    return (l / S) == (rhs.l / S) ? (((l / S) & 1) ? r < rhs.r : r > rhs.r) : ((l / S) < (rhs.l / S));
}
```

对于奇数块来说右指针顺序向右走；对于偶数块来说右指针顺序向左走，避免每到下一个块先往回走再向右走。理论能快一倍。

## 可修莫队

加一维时间，即有三维坐标 $(l,r,time)$​​。每次修改一个点，时间 time+1。之后按照 $ql$​​ 的块为第一关键字，$qr$ ​​的块为第二关键字，$time$ ​​按从小到大排。令块的大小为$S = n^{\frac{2}{3}}$​​，复杂度可简化至$O(n^\frac{5}{3})$​​​​（易证）。

```cpp
bool operator<(const node& rhs) {
    if (l / S != rhs.l / S)
        return l / S < rhs.l / S;
    if (r / S != rhs.r / S)
        return r / S < rhs.r / S;
    return time < rhs.time;
}
```

## 括号序树上莫队

一般的莫队只能处理线性问题，我们要把树强行压成序列。

我们可以将树的括号序跑下来，把括号序分块，在括号序上跑莫队。

具体怎么做呢？

dfs 一棵树，然后如果 dfs 到 x 点，就 `push_back(x)`，dfs 完 x 点，就直接 `push_back(-x)`，然后我们在挪动指针的时候，

- 新加入的值是 x --->`add(x)`
- 新加入的值是 - x --->`del(x)`
- 新删除的值是 x --->`del(x)`
- 新删除的值是 - x --->`add(x)`

这样的话，我们就把一棵树处理成了序列。

然后每次添加 / 删除一个点，这个点的对答案的的贡献是可以在 $O(1)$ 时间内获得的。​

对于查询一条路径来说，发现因为他会把起点的子树也扫了一遍，产生多余的贡献，怎么办呢?

因为扫的过程中起点的子树里的点肯定会被扫两次，但贡献为 0。

所以可以开一个 vis 数组，每次扫到点 x，就把 $v i s_{x}$ 异或上 1。

如果 $v i s_{x}=0$​​​ ，那这个点的贡献就可以不计。

所以可以用括号序树上莫队来求。

修改的话，加上一维时间维即可，变成带修改树上莫队。

然后因为所包含的区间内可能没有 LCA，对于没有的情况要将多余的贡献删除，然后就完事了。

## 一些习题

### P3604 美好的每一天

回归天空是一件庄重的事情，所以卓司决定让大家分批次进行，给每个人给了一个小写字母 'a'->'z' 作为编号

一个区间的人如果满足他们的 **编号重排之后可以成为一个回文串**，则他们可以一起回归天空，即这个区间可以回归天空。

由于卓司是一个喜欢妄想的人，他妄想了 m 个区间，每次他想知道每个区间中有多少个子区间可以回归天空。

由于答案仅跟字母的奇偶性有关，考虑异或：

将字母按 `1<<i` 编号，发现对于一个区间能够集体飞升，要不整体异或为 0，要不为 $2^k$。由于该题的 **前缀异或和** 具有可加性，故考虑$a_i = \bigoplus\limits_{j=1}^{i}c_j$，然后套莫队，注意区间是 $[l-1,r]$ 中选两个数异或，新加入（或减去）的$a_p$与跟$a_p$差一位的$a_q$或$a_p$​对应的方案异或。

### 大爷的字符串题

求区间 $[l,r]$ ​的众数的出现次数。

只需要在莫队的基础上，加一个 $num[i]$ ​表示出现次数为 $i$ ​的数有多少个，这样就能维护众数了。

### P4396 [AHOI2013]作业

此时己是凌晨两点，刚刚做了 Codeforces 的小 A 掏出了英语试卷。英语作业其实不算多，一个小时刚好可以做完。然后是一个小时可以做完的数学作业，接下来是分别都是一个小时可以做完的化学，物理，语文……小 A 压力巨大。

这时小 A 碰见了一道非常恶心的数学题，给定了一个长度为 n 的数列和若干个询问，每个询问是关于数列的区间表示数列的第 l 个数到第 r 个数)，首先你要统计该区间内大于等于 a，小于等于 b 的数的个数，其次是所有大于等于 a，小于等于 b 的，且在该区间中出现过的数值的个数。

小 A 望着那数万的数据规模几乎绝望，只能向大神您求救，请您帮帮他吧。

1e5 的数据，$O(n\sqrt{m}logn)$​​ 过不了。

细想莫队的实现本质，通过 $O(n\sqrt{m})$ 的移动来实现 $O(m)$ 的查询，是这样一个数据结构。那么需要一个快速修改，低速查询的 ds：值域分块。将值域分块后，修改可以 $O(1)$，查询均摊至 $O(m\sqrt{n})$。总复杂度 $ O(n\sqrt{m} + m\sqrt{n})$​

### P5355 [Ynoi2017]由乃的玉米田

由乃在自己的农田边散步，她突然发现田里的一排玉米非常的不美。

这排玉米一共有 N 株，它们的高度参差不齐。

由乃认为玉米田不美，所以她决定出个数据结构题

这个题是这样的：

给你一个序列 a，长度为 n，有 m 次操作，每次询问一个区间是否可以选出两个数它们的差为 x，或者询问一个区间是否可以选出两个数它们的和为 x，或者询问一个区间是否可以选出两个数它们的乘积为 x ，或者询问一个区间是否可以选出两个数它们的商为 x（没有余数） ，这四个操作分别为操作 1,2,3,4。

选出的这两个数可以是同一个位置的数。

莫队 + bitset

对于减法，只需要 `cur & (cur>>x)`，看是否有 1 即可。

对于加法，存一个按值域 reverse 的 bitset，则 `cur & (rev >> (N - x))`，$N$​ 为值域上界。

对于乘法，暴力枚举出现因数即可。

对于除法：对于大于 $M = \sqrt{n}$ ​的，直接暴力枚举，复杂度为 $O(\sqrt{n})$​；对于小于等于 $M$ ​的，另外有一个 trick：对于单个 $x$​，$O(n)$ ​考虑 `pre[i]` 为 $i$ ​上次出现的位置，$res[j]$ ​为 $[l,j]$ ​中存在两个数满足条件的最右的 $l$​。只要查询区间 $[ql,qr]$​ 满足 $ql<=res[qr]$ ​即为 `true`（这个 trick 的原理就是能够在 $O(n)$​ 的复杂度下找到以某个点为右端点的最短满足条件的区间）。总复杂度为 $O(n\sqrt{n})$​。

### P5268 [SNOI2017]一个简单的询问

给你一个长度为 $N$​ 的序列 $a_{i}, 1 \leq i \leq N$​，和 $q$​ 组询问，每组询问读入 $l_{1}, r_{1}, l_{2}, r_{2}$，需输出
$$
\sum_{x=0}^{\infty} \operatorname{get}\left(l_{1}, r_{1}, x\right) \times \operatorname{get}\left(l_{2}, r_{2}, x\right)
$$
$\operatorname{get}(l, r, x)$ 表示计算区间 $[l, r]$ 中，数字 $x$ 出现了多少次。

由于对于区间 $[l,r] $ ​​某元素 $x$ ​​的个数满足差分性质 `cnt[r][x] - cnt[l-1][x]`，故将问题转化一下：

令 $g(r,x)$ ​为 $x$ ​元素在 $[1,r]$​ 出现的次数，原问题转化为 $\sum g(r_1,x)g(r_2,x) - \sum g(r_1,x)g(l_2-1,x) - \sum g(l_1-1,x)g(r_2,x) + \sum g(l_1-1,x)g(l_2-1,x)$​，然后莫队一下就好。

### CF940F Machine Learning

可修莫队加小结论。

问一个区间的数出现次数的 mex，带修改。移动指针是带修莫队的基本操作。考虑暴力查询：

假设区间 $[l,r] $ ​的出现次数的 mex 为 $x$​，有 $1+2+\dots+x-1<=r-l+1$​，可知 $x$ ​是根号级别的，直接暴力查就是了。

### CF1436E Complicated Computations

求一个数列的所有连续子数列的 mex 值的 mex

考虑依次判断 $i$ 是否出现在子序列 $\operatorname{mex}$ 中，显然 $i$ 能出现当且仅当存在两个相邻的 $i$ 使得他们之间的区间 mex 为 $i$

由于相邻的 $i$ 总计只有 $O(n)$ 组，题目可以转化为 $n$ 组询问区间 $\mathrm{mex}$​ 这是个经典问题，可以离线莫队处理。注意要使用值域分块。

增加：当当前mex答案=x且添加进来的就为x，则要while向上找（这个可以用值域分块优化）。

删除：当删掉的x小于当前mex，则让mex = x。

