# 线段树

由于每一行最多只有两个蓝色区间（需要向下递归的节点）和两个红色区间（lazy-tag放到这里停止的节点），因此线段树区间修改的自带常数为 4，共有 logn 层。每层至多访问 4 个节点，故复杂度为 $O(4\log n)$​。

感性证明：想要区间多，一开始必然在 [1,n] 中取跨过 mid 的子区间；然后会被划分成两个左右子区间。对于左子区间，是靠右连续的，即每次最多只能分出一个向下递归的子区间；右子区间同样。所以访问的区间个数是 $O(4\log n)$ 的。

## 一些习题

### 例题七 2018 ACM-ICPC 上海大都会 H A Simple Problem with Integers

跟循环节有关系的题目。先有个结论：对于 1~p-1 的每一个数，取平方都会遇到一个循环节，而最大的那个循环节是所有循环节的公倍数。所以在块未被更新最大入环距离的次数前便暴力更新每个节点，否则可以整块更新(先预处理一遍 sum[] 值，sum[] 数组大小取决于最长循环节长度)。

由于在部分块尚未进入循环节时，需要对块对应的每个点进行暴力修改。学到了如何从区间修改变逐点修改（具体可以看代码）。

建议（写本文的明天）先学龟兔赛跑算法，然后再做题。另外线段树还有一个类似的黑题，估计明天一天学线段树。

### P3747 [六省联考2017]相逢是问候

**线段树+扩欧**

发现当某一位的操作次数叠到若干次时，由于扩欧的模数往上叠时不断减小至1，继续操作值不发生改变。

#### 引理1

对一个数 $a_0$​​ 进行 $a_{i+1} = \varphi(a_i)$​ ​的操作次数至多为 $logn$​​。

粗略证明：当 n 为奇数时，其必由若干个两两互质的奇素因子组成。对于质数 $p,\varphi(p^n) = p^{n-1} * (p-1) \%2 = 0$​，故 $\varphi(n)$ ​必有素因子 2，即 $\varphi(n)$ ​​为偶数。

当 $n$ 为偶数时，素因子 2 中拿一个 2 献祭（x），变成 1，$n>=2\varphi(n)$。

所以复杂度为 $O(logn)$​。

回到线段树上的修改，对某个数不断叠加操作次数，将模数往上放的过程中还需要注意幂次与模幂次的模数的大小关系。同时若采用 上帝与集合的正确用法 的dfs来做的话，线段树单词修改+扩欧叠幂次+快速幂的复杂度高达 $O(log^3n)$​​​。

由于能确定每一层的模数 $P,\varphi(P),\varphi(\varphi(P)),...$​​，除了最后一层幂是 $ a[i]$ ​​外（虽然实际操作不需要担心）。取模的底都是 $c$​​，故去预处理以 $c$ ​​为底的若干幂次，按模数分组。当底数 $c$ ​​叠加幂次叠到若干值到需要取模，即 $(i,j),i$ ​​为 $c$ ​​的幂，$j$ ​​为模数分组，$c^i\geq mod[j]$ ​​时，用一数组记录该状态代表 $(i,j)$ ​​需要加模数。

可以发现 $i$​​​​​ 的取值高达 $1e8$​​​​​，遂分块暴力处理，分 $c^{k_1*10000+k_2}$​​ ​​​两组 $k_1,k_2\in[0,10000]$​​​​​，则指数 $i = (i/10000)*10000 + (i \% 10000)$​​​​​。两组 $k_1,k_2$​​​​​ 分别记录与模数的关系，合并是否加模数的信息。这时取幂运算转为 $O(1)$。总复杂度为 $O(logn\sqrt{n}) + nlog^2n)$​​​​​​

### [BZOJ3589] 动态树

树剖+线段树，主要讲线段树。涉及的操作是对若干个区间进行覆盖操作，被覆盖的元素统计起来，若元素被覆盖若干次仅记一次。统计完后清空。

首先是覆盖操作：

对于完整块来说，将覆盖值 $cov(p)$​ ​赋值于 $sum(p)$​​，然后向上传递，最后查询仅需查询 $cov(1)$​​；

对于清除操作，只需在节点 1 打上清除标记，下放的时候**优先下放清除标记，将左右子区间的cov(),覆盖标记给清除**，再下放其他标记，以保证后面来的覆盖标记能准确地下放。

### P2023 [AHOI2009] 维护序列

区间乘+区间加。这道题在打标记的过程中始终要保持下放给子区间（其对应值为 $v$​）的原则为 $val = tag_{\times} \times val + tag_{+}$​。故对于一个完整区间的打标记：

> 当区间+一个数 v，$tag_{+} += v$​
>
> 当区间*一个数 v，$tag_{\times} *= v,tag_{+} *= v$​

### P6327 区间加区间sin和

$\sin (a+x) = \sin(a)\cos(x)+\sin(x)cos(a)$

$cos(a+x) = \cos(a)\cos(x) - \sin(a)\sin(x)$

利用公式维护 $\sin ,\cos$​ 就可以了。

### P5482 [JLOI2011]不等式组

解不等式，在对应可行区间赋值就行。

### P3792 由乃与大母神原型和偶像崇拜

下面一题的弱化版。有一种利用 hash 的正确率高解法，比较简单就不记录了，题解区有。

### P5278 算术天才⑨与等差数列

一段序列重排后是公差为k的等差序列当且仅当：

>区间 $[l+1,r]$​​ ​维护差分 $\operatorname{gcd} = k$​​​（注意这里没有 $[l,l]$​​​。区间 gcd 维护时记得要和 $a[l]$ ​​​​gcd 一次）
>
>区间 $\max - \min = k * (r - l)$​
>
>区间内数不出现同样的。用set维护最近相同数位置pre。

这里讲讲如何维护 pre。

$S[i]$​​​​​ 存放数 $v$​​​​​ 离散后的值$i$​​​​​对应区间的位置关系。比如数 $114514$​​​​​ 对应 $S[3]$​​​​​，其在区间的位置为 $1,14,514$​​​​​，则 $S[3] = \{1,14,514\}$​​​​​。

将 $v_1\rightarrow v_2$​​​​​​，修改位置为 $x$​​​​​​，那么发生 pre 改变的位置就有：$x$​​​​​​，$v_ 1$​​​​​​ 在 x 位置的后缀的位置 $y$​​​​​​，$v_2$​​ ​​​​在x位置的后缀的位置 $z$​​​​​​。将这几个位置 push 到待修改位置的数组里，最后修改即可。修改前记得维护 $S[i]$​​​​​​，修改时写一个函数 $pre()$​​​​​​​ 简洁很多。

具体的实现可参照下面一题的代码。

### P6617 查找 Search

问区间中有无 $a_x+a_y = w$ ​的组合。

用线段树维护互补的 pre 位置即可。这里维护的互补，是互补区间最小的。比如 w=4，区间为 $1,3,3,3,3$​​​​​，那么只有最前面的 3 需要维护 pre = 1，其余的等于 0 就可以了（因为大区间若合法，其必定对应一个合法的子区间）这样能保证修改操作是常数级别。由于要保证这样的性质有一些细节，具体看代码中的函数 `pre()`。

### P5069 [Ynoi2015]纵使日薄西山

严格上不属于线段树的题目。但用到了（或者必须要用到）能常数修改的性质。

对于一个极长单调区间来说，极大值必然选到，然后每隔一点就需要操作一个点（即极长区间内操作点的奇偶性跟极大值）。根据这个性质，就可以根据奇偶性用树状数组直接统计一个极长单调区间的答案贡献。

如何记录一段区间是极长单调区间？只需要用 set 维护所有的极值点即可。

修改一个值，会影响至多5个最近极值点（包括其本身）的答案统计，同时会影响相邻两点及其本身是否会成为（或者撤销）极值点的状态。

还有一些细节，比如连续区间相同的数，开头的数若大于前面的数则让其为极大值，尾部的数若小于后面的数则让其为极小值（这个在代码中 `check(int x)` 一个 if-else 就处理完了 6 种情况。细品）具体看代码和[扶苏大佬的博客](https://www.cnblogs.com/yifusuyi/p/11108521.html)。代码注释的很清楚了。

### T161038 查狄伦12T 1954年型

先讲讲 50pt 做法。

首先式子可以写成 $(Amax_{l,r}-Amin_{l,r})(Bmax_{l,r}-Bmin_{l,r})(Cmax_{l,r}-Cmin_{l,r})$​​​​​，这意味着，当新增了一个点，若一类区间（以 A 序列举例）左边的极差整体加上了 x，即可以线性去维护它。比如 $1,2,3,4,5,6$​​​​​，当前维护的极差（和）为 $5,4,3,2,1,0$​​​​​，此时新加入 $7$​​​​​，那么前面的极差和要加上一个增量 x。那么现在维护 A 序列极差 a，B 序列极差 b，C 序列极差 c，A 序列极差 * B 序列极差，A 序列极差 * C 序列极差，B 序列极差 * C 序列极差，A 序列极差 * B 序列极差 * C 序列极差（这里在线段树上维护的都是节点区间的和）；当修改某区间 [l,r] 的极值时（还是以 A 序列为例，极差增加 x），a += (r - l + 1) * x，ab += bx，ac += cx，abc += abx。当对于一个位置 $r$​​​​​ 的三个序列都修改好时，此时的 abc 值表示以当前 $r$​ ​​​​为右端点，新增的区间 $[l,r],l\in[1,r-1]$​ ​​​​所增加的贡献之和。那么维护的复杂度为 $O(n\log n)$​​​​​​​​​​​​。

理解清楚上面的思路，以及式子的拆分，那么 100pt 的做法就明确了：对于固定右端点，区间最大值 / 最小值往左单调不减 / 不增。对于新加进来的点（这里以最大值为例），左区间所有比当前点值小的 $Amax_{l,r}$​ ​都加一个增量 x。那么单调栈去维护前缀区间最大值/区间最小值，然后对极差会加一个增量的统一区间修改一波。由于一个点至多被加进来 / 删除一次，而单次区间修改复杂度为 $O(8\log n)$​​ 故总复杂度为 $O(8n\log n)$​​​​​。

### T161036 GSOR 1008

直接分治做。

假设两个子区间的答案已统计完，那么就剩区间覆盖左右两区间端点的子区间的答案贡献了。

（见[第一周模拟赛讲评](C:\Users\Administrator\Documents\Tencent Files\1019386658\FileRecv\模拟赛讲评.pptx)的图片）先 $O(n)$​​​ 分别计算绿、紫区间的区间最值 x，后缀/前缀最值 y。然后去考虑两个区间合并后左 $ x_1$​ ​​/ 中间 $y_1+y_2$ ​​​/ 右 $x_2$ ​​​成为区间最大值时应满足的条件，此时就能转化成二维偏序问题，然后用排序 + BIT 解决。