# 树分块

对于树上分块，有若干种形式。比较经典的是，设一个阈值 $S$，然后随机在数上标记 $S$ 个关键点。对于其他非关键点来说，纳入祖先中最近的关键点对应的块。这样就能保证块的数量确定在 $S$ 个内。

下面根据上述思路给出一个确定性算法：

> 对于有根树 rt，每次从最深节点 u 向上搜。如果祖先 $1 \sim S$​ 都不是关键点，此时在祖先 $S$​ 那标记为关键点。照这样分块，每个关键点都至少包含了独立的 $S$ ​个点（相对于其他关键点来说）。故算良好的分块方式。对于每个点记录一个 `mxd[u]` 表示当前子树可达的最深点。若 `mxd[u] - d[u]>=S` 则让 $u$​ 作为关键点。
>
> 由于树分块中，关键点间以跳链的形式来更新信息，不妨把以根节点为末端的路径上所有关键点对的信息都预处理出来，此时查询中可以 $O(1)$ ​完成块间跳链。具体地，依据树遍历过程的实质是栈的进出，在遍历时将关键点推入栈中。当遍历到一个点 $u$ ​时，栈元素 $sta[1\sim top]$ ​依次是第 $top,top-1,\dots,1$ ​级祖先。最多有 $O(\frac{n^2}{S^2})$ ​对点需要处理（实际上比这个小一些）。
>
> 对于路径 $<u,v>$​，设 $t = \operatorname{lca}(u,v)$​，则仅需考虑处理 $ <u,t>,<v,t>$ ​两条路径上的信息。对于 $<u,t>$​，在有关键点的情况下，$u$ ​暴力走到关键点，然后 tp 到离 $t$ ​最近的关键点，之后再暴力走到 $t$ ​即可。

## 一些习题

### P6177 Count on a tree II【模板】树分块

给定一个 $n$​ 个节点的树，每个节点上有一个整数， $i$​ 号点的整数为 $v a l_{i}$​。

有 $m$​ 次询问，每次给出 $u^{\prime}, v$​，您需要将其解密得到 $u, v$​，并查询 $u$​ 到 $v$​​​ 的路径上有多少个不同的整数。

对于不同颜色的个数用 bitset 处理。由于基于阈值 $S$​，点对是 $n^2$​ 级别的，而时间复杂度是线性的，此时可以通过提高阈值来大幅降低空间复杂度。该题设阈值 $S=1000$​​。

另外，对于 bitset 来说，令 `bs,bt1,bt2` 均为 bitset，`bs = bt1 | bt2` 和 `bs = bt1,bs |= bt2`，后者不需要多开一次空间，这样可以省空间。

