# 垂线法

定义 $a_{i, j}$ 为矩阵中是否有障碍点，若 $a_{i, j}=1$ 则有障碍点，反之则无障碍点； $u p_{i, j}$ 为点 $(i, j)$ 对应的悬线长度，初始化当点 $(i, j)$ 不是障碍点时 $u p_{i, j}=1$ 。

显然 $u p_{i, j}$ 很容易通过递推求出，也就是说，当点 $(i-1, j)$ 不是障碍点时， $u p_{i, j}=u p_{i-1, j}+1$ 。

关键在于如何求出 **每条悬线能够往左右扩展的最大长度** 。一条悬线往左边能扩展到的最大长度一定是它包含的所有点能往左边扩展到的最大长度的最小值，往右同理。这就是说，可以通过枚举悬线上每个点往左右扩展到的最大长度来求解一条悬线往左右扩展到的最大长度。
令 $l_{i, j}, r_{i, j}$​​ 分别为点 $(i, j)$​​ 往左/右能扩展到第几列，初始化即为当点 $(i, j)$​​ 不是障碍点时 $l_{i, j}=r_{i, j}=j$​​ 。
$l_{i, j}$​​ 需要从左到右推, 即 $j$​​ 从 2 到 $m$ ，而 $r_{i, j}$​​ 需要从右到左推, 即 $j$​​ 从 $m-1$​​ 到 $1 $​​ 。​​​​​​

证明悬线法必然访问了所有极大子矩阵：由于每个极大子矩阵必然存在一个坏点在上边（边界的子矩阵也看作坏点挡住），否则可以继续扩大。那么在该坏点便能引下一条悬线，在悬到底端前都在边缘上（显然）。故证毕。

另外有种 N,M 很大，但坏点（设 S 个）很小的极大子矩阵找法，利用极大化思想在 $O(S^2)$​​​​ 处理完。没遇到题目，故待学。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

struct suspended_line {
    vector<vector<int>> a, l, r, up;  //l_{i,j}表示往左延多远，up表示往上延多远。run时l_{i,j}表示i,j到悬线顶的悬线部分左边可以延多远
    int n, m;
    suspended_line(int n, int m, vector<vector<int>> a)  //a[i][j] = 0表示无障碍
        : n(n), m(m), a(a) {
        l = vector<vector<int>>(n, vector<int>(m));
        r = l, up = l;
    }
    void run() {  //必然访问了所有极大子矩阵
                  /*以下初始化l,r。对于l,r的初始化根据题目而定。以下为求极大子矩阵时的初始化*/
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (!a[i][j]) {
                    l[i][j] = r[i][j] = j;
                }
            }
        }
        for (int i = 0; i < n; ++i) {
            for (int j = 1; j < m; ++j) {
                if (!a[i][j] && !a[i][j - 1]) {
                    l[i][j] = l[i][j - 1];
                }
            }
        }
        for (int i = 0; i < n; ++i) {
            for (int j = m - 2; j >= 0; --j) {
                if (!a[i][j] && !a[i][j + 1]) {
                    r[i][j] = r[i][j + 1];
                }
            }
        }
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (!a[i][j]) {
                    up[i][j] = 1;
                    if (i && !a[i - 1][j]) {
                        up[i][j] += up[i - 1][j];
                    }
                }
            }
        }
        long long ans = 0;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (i >= 1 && !a[i][j] && !a[i - 1][j]) {
                    l[i][j] = max(l[i][j], l[i - 1][j]);
                    r[i][j] = min(r[i][j], r[i - 1][j]);
                }
                ans = max(ans, 1ll * up[i][j] * (r[i][j] - l[i][j] + 1));  //极大子矩阵的最大面积
            }
        }
    }
};
int main() {
    return 0;
}
```


## 一些题目

## P4858 [PA2013]Karty

网格图，仅含 _ 和 X ，要求找到一个极大的子矩阵，可以覆盖完所有的 X ，子矩阵可以重复覆盖。

结论：仅需要考虑覆盖完贴边的悬线，即仅考虑所有垂下来长度为 x 的，能往左右延伸最大值的最小值，上下左右做一次即可。

证明：既然贴边线的悬线能够覆盖，那么必然能通过平移子矩阵来将非贴边线的悬线覆盖。证毕。

