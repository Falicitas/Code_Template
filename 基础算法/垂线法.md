# 垂线法

定义 $a_{i, j}$ 为矩阵中是否有障碍点，若 $a_{i, j}=1$ 则有障碍点，反之则无障碍点； $u p_{i, j}$ 为点 $(i, j)$ 对应的悬线长度，初始化当点 $(i, j)$ 不是障碍点时 $u p_{i, j}=1$ 。

显然 $u p_{i, j}$ 很容易通过递推求出，也就是说，当点 $(i-1, j)$ 不是障碍点时， $u p_{i, j}=u p_{i-1, j}+1$ 。

关键在于如何求出 **每条悬线能够往左右扩展的最大长度** 。一条悬线往左边能扩展到的最大长度一定是它包含的所有点能往左边扩展到的最大长度的最小值，往右同理。这就是说，可以通过枚举悬线上每个点往左右扩展到的最大长度来求解一条悬线往左右扩展到的最大长度。
令 $l_{i, j}, r_{i, j}$​​ 分别为点 $(i, j)$​​ 往左/右能扩展到第几列，初始化即为当点 $(i, j)$​​ 不是障碍点时 $l_{i, j}=r_{i, j}=j$​​ 。
$l_{i, j}$​​ 需要从左到右推, 即 $j$​​ 从 2 到 $m$ ，而 $r_{i, j}$​​ 需要从右到左推, 即 $j$​​ 从 $m-1$​​ 到 $1 $​​ 。​​​​​​

证明悬线法必然访问了所有极大子矩阵：由于每个极大子矩阵必然存在一个坏点在上边（边界的子矩阵也看作坏点挡住），否则可以继续扩大。那么在该坏点便能引下一条悬线，在悬到底端前都在边缘上（显然）。故证毕。

```cpp
```




## 一些题目

## P4858 [PA2013]Karty

网格图，仅含 _ 和 X ，要求找到一个极大的子矩阵，可以覆盖完所有的 X 且子矩阵里不含 _，子矩阵可以重复覆盖。

结论：仅需要考虑覆盖完贴边的悬线，即仅考虑所有垂下来长度为 x 的，能往左右延伸最大值的最小值，上下左右做一次即可。

证明：既然贴边线的悬线能够覆盖，那么必然能通过平移子矩阵来将非贴边线的悬线覆盖。证毕。

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;

#define clr(a) memset(a, 0, sizeof(a))
#define debug(a) cout << #a << "=" << a << " "
const int N = 2505;

int n, m, ml, mw, s;
int a[N][N], tmp[N][N], f[2][N], L[2][N], R[2][N], l[N], r[N];
int mxc[N], mxr[N];

void work(int mxc[]) {
    for (int j = 1; j <= m; j++)
        L[0][j] = 0, R[0][j] = m + 1, f[0][j] = 0;
    for (int i = 1, cur = 1; i <= n; i++) {
        l[0] = 0, r[m + 1] = m + 1;
        for (int j = m; j; --j)
            if (a[i][j])
                r[j] = r[j + 1];
            else
                r[j] = j;
        for (int j = 1; j <= m; j++)
            if (a[i][j]) {
                l[j] = l[j - 1], f[cur][j] = f[cur ^ 1][j] + 1, L[cur][j] = max(L[cur ^ 1][j], l[j]), R[cur][j] = min(R[cur ^ 1][j], r[j]);
                int r = f[cur][j], c = R[cur][j] - L[cur][j] - 1;
                mxc[r] = min(mxc[r], c);
                if (!a[i + 1][j]) {
                    for (int p = r + 1; p <= n; p++)
                        if (mxc[p])
                            mxc[p] = 0;
                        else
                            break;
                }
            } else
                l[j] = j, f[cur][j] = 0, L[cur][j] = 0, R[cur][j] = m + 1;
        cur ^= 1;
    }
}
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) {
        char ch = getchar();
        while (ch != '_' && ch != 'X')
            ch = getchar();
        for (int j = 1; j <= m; j++)
            a[i][j] = ch == 'X', ch = getchar();
    }
    ml = mw = N, s = 0;
    memset(mxc, 0x3f, sizeof(mxc)), memset(mxr, 0x3f, sizeof(mxr));
    work(mxc);
    for (int j = 1; j <= m; j++)
        for (int i = 1; i <= n / 2; i++)
            swap(a[i][j], a[n - i + 1][j]);
    work(mxc);
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            tmp[j][i] = a[i][j], a[i][j] = 0;
    for (int i = 1; i <= m; i++)
        for (int j = 1; j <= n; j++)
            a[i][j] = tmp[i][j];
    swap(n, m);
    work(mxr);
    for (int j = 1; j <= m; j++)
        for (int i = 1; i <= n / 2; i++)
            swap(a[i][j], a[n - i + 1][j]);
    work(mxr);
    swap(n, m);
    mxr[0] = n + 1;
    for (int i = n, j = 1; j <= m; j++)
        for (; i > mxr[j]; --i)
            mxc[i] = min(mxc[i], j - 1);
    for (int i = 1; i <= n; i++)
        if (i * mxc[i] > s)
            s = i * mxc[i], ml = i, mw = mxc[i];
    printf("%d %d\n", ml, mw);
    return 0;
}
```

